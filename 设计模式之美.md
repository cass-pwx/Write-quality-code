# 设计模式之美

![img](.\设计模式之美.assets\f3262ef8152517d3b11bfc3f2d2b12d3.png)

# 23种设计模式（GOF23）

## 1、是什么

- 设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。
- 他不是语法规则，而是一套用来提高代码可复用性，可维护性，可读性，稳健性以及安全性的解决方案
- 设计模式的本质是面向对象设计原理的实际应用，是对类的封装性，继承性和多态性以及类的关联关系和组合关系的充分理解

## 2、基本要素

- 模式名称
- 问题
- 解决方案
- 效果

## 3、有什么

- 创建型模式：帮助我们去创造对象，而不是使用 new 运算符直接实例化对象
  
  ​	这些设计模式提供了一种在**创建对象**的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
  
  - **单例模式**：唯一实例
  - **工厂模式**：简单工厂和工厂，简单工厂是一个工厂生产多个品牌的车，工厂是一个工厂生产一个品牌的车
  - **抽象工厂模式**：超级工厂，抽象出共同点，多维（华为和苹果都生产路由器和手机）
  - **建造者模式**：一砖一瓦的拼上去，步骤不变，但是顺序可以变，要有有个指挥者I（进阶：无指挥者，客户端自行搭配）
  - 原型模式：复制原来的类生成新的类
  
- 结构性模式
  
  ​	这些设计模式关注**类和对象的组合**。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
  
  - **适配器模式**（Adapter Pattern）：通过继承和组合实现原来的类，然后实现要配对的接口
  
  - **桥接模式**（Bridge Pattern）：有点像多继承，多维度。就像一座桥，可以把两个变化的维度连接起来!
  
  - 过滤器模式（Filter Criteria Pattern）：就是通过过滤器过滤出你想要的东西
  
  - 组合模式（Composite Pattern）：统一接口，然后树状排列生成有层次的数据
  
  - **代理模式**（Proxy Pattern）：静态和动态，静态相当于一个中介，动态依赖两个类，然后实现动态生成代理的类
  
  - **装饰器模式**（Decorator Pattern）：加强原来的类的功能，一个气球经过装饰变成了红色的气球
  
  - 外观模式（Facade Pattern）：统一一个接口进行调用，controller层
  
  - 享元模式（Flyweight Pattern）：没有再创建，有就直接用（String字符串在缓存池，连接池）
  
    
  
- 行为型模式
  
  ​	这些设计模式特：别关注对象之间的**通信**
  
  - **模版方法模式**：确定一个框架，然后子类实现具体的细节
  - 命令模式：将请求封装成命令
  - **迭代器模式**：容器的迭代器
  - **观察者模式**：发布-订阅模式，一个类发生了变化，依赖他的对象自动发生相应的变化
  - 中介者模式：由多对多变成了多对一
  - 备忘录模式：快照
  - 解释器模式：编译原理的文法，通过文法来实现组合
  - **状态模式**：定义不同的状态做不同的事情
  - **策略模式**：可以根据不同的环境选择不同的算法，上下文
  - **职责链模式**：链表，一层层进行比较，能处理就处理，不能处理继续往后传递
  - 访问者模式：通过不同的方法去观察同一个东西，就能获得不同的结构，构件一个元素接口和一个访问者接口
  
- **J2EE 模式**

  ​	这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

  - MVC 模式（MVC Pattern）
  - 业务代表模式（Business Delegate Pattern）
  - 组合实体模式（Composite Entity Pattern）
  - 数据访问对象模式（Data Access Object Pattern）
  - 前端控制器模式（Front Controller Pattern）
  - 拦截过滤器模式（Intercepting Filter Pattern）
  - 服务定位器模式（Service Locator Pattern）
  - 传输对象模式（Transfer Object Pattern）



# OOP七大原则

## 开闭原则：对扩展开放，对修改关闭

- 你扩展可以，但是不要改变之前的东西

## 里氏替换原则：继承必须确保超类所拥有的所有性质在子类中仍然成立

- 你要实现子类可以，但是你要保证能够拥有父类所有的性质
- 企鹅，鸵鸟就不符合

## 依赖倒置原则：要面向接口编程，不要面向实现编程

- 原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
- 依赖倒置原则是实现开闭原则重要途径之一。
- 就是面向接口

## 单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性

- 指类变化的原因，一个类应当有且只有一个引起它变化的原因，若有多个则该类需要拆分。
  
- 如果一个对象承担了太多职责，至少会存在以下两个缺点：
  
  - 当一个职责变化时，可能会削弱或抑制该类实现其他职责的能力。
  
  - 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。
  
- 单一职责同样也适用于方法。一个方法应该尽可能做好一件事情，如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。

- 高内聚，低耦合

## 接口隔离原则：要为各个类建立他们需要的专用接口

- 和上一个差不多，主要就是要求接口的粒度要小，一个接口做一件事
- 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
- 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；
- 接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

## 迪米特原则：只与你的直接朋友交谈，不跟“陌生人”说话

- 两个类的联系使用第三方，降低两个类的耦合

## 合成复用原则：尽量先试用组合或者聚合等关系关联关系来实现，其次才考虑使用继承关系来实现

- 类和类之间的关系尽量是“have a”关系（组合），而不是“is a”的关系（继承）



# 单例模式

## 1、是什么

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**应用实例：**

- 1、一个班级只有一个班主任。
- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

- 1、要求生产唯一序列号。
- 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
- Windows的任务管理器
- Windows的回收站
- 项目中，读取配置文件的类，一般也只有一个对象，没必要每次都去new对象读取
- 网站的计数器一般也会采用单例模式，可以保证同步
- 数据库连接池的设计一般也是单例模式
- 在Servlet编程中，每个Servlet也是单例的
- 在Spring中，每个Bean默认就是单例的

**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

核心作用：保证一个类只有一个实例，并且提供一个访问该类的实例的全局访问点

## 2、测试

```java
public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
    //这个是核心
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}

```

从 singleton 类获取唯一的对象。

```java
public class SingletonPatternDemo {
   public static void main(String[] args) {
 
      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();
 
      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();
 
      //显示消息
      object.showMessage();
   }
}
```

## 3、单例模式的几种实现方式

单例模式的实现有多种方式，如下所示：

### 1、饿汉式

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式比较常用，但容易产生垃圾对象。
优点：没有加锁，执行效率会提高。
缺点：类加载时就初始化，浪费内存。
它基于 classloader机制 （类加载机制：**JVM在类加载的过程，保证了不会初始化多个 static 对象**）避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

```java
public class Hungry {
    private static Hungry instance = new Hungry();
    private Hungry (){}
    public static Hungry getInstance() {
        return instance;
    }
}
```

由于饿汉式存在资源浪费，所以就出现了懒汉式

### 2、懒汉式，线程不安全

**是否 Lazy 初始化：**是

**是否多线程安全：**否

**实现难度：**易

**描述：**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java
public class LazyMan {
    private static LazyMan instance;
    private LazyMan (){
        System.out.println(Thread.currentThread().getName()+"OK");
    }

    public static LazyMan getInstance() {
        if (instance == null) {
            instance = new LazyMan();
        }
        return instance;
    }
    //跑的时候，我们会发现，他有时候不止创建了一个线程
    public static void main(String[] args){
        for(int i=0;i<10;i++){
            new Thread(()->{
                LazyMan.getInstance();
            }).start();
        }
    }
}
```

### 3、双检锁/双重校验锁（DCL，即 double-checked locking）

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**较复杂

**描述：**这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。

```java
public class DCLLazyMan {
    //DCL + 原子性操作
    private volatile static DCLLazyMan dclLazyMan;		//DCL懒汉式还是不安全，因为创建对象不是原子操作
    private DCLLazyMan (){}
    public static DCLLazyMan getInstance() {
        if (dclLazyMan == null) {
            synchronized (DCLLazyMan.class) {		//第一层
                if (dclLazyMan == null) {			//第二层
                    dclLazyMan = new DCLLazyMan();  //不是原子性操作
                    /*
                     * 正常我们创建新的对象有三个步骤：
                     * 	1、分配内存空间
                     * 	2、执行构造方法，初始化对象
                     * 	3、把对象指向空间
                     * 但是我们知道，有时候并不是按顺序执行的，
                     * 这样就可能存在线程A在创造，这时候线程B把线程A的空间占了，这时候创造出来的线程就是空的
                     * 这也就是为什么我们要使用volatile的原因了
                     */
                }
            }
        }
        return dclLazyMan;
    }
}
```

到了这里之后，可能还有有人提出静态内部类

![image-20210626114159449](D:\idea\23种设计模式.assets\image-20210626114159449.png)

其实牛逼的人，会发现，其实都是不安全的，为什么呢？因为我们Java有一种很霸道的东西------>反射	

我们实验一下

```java
    public static void main(String[] args) throws Exception {
        DCLLazyMan instance = DCLLazyMan.getInstance();
        Constructor<DCLLazyMan> constructor = DCLLazyMan.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        DCLLazyMan instance2 = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

运行一下，我们可以很明显的看到，两个对象的Hash值不同

这个其实很好解决，只要在我们的构造方法中加个锁就行

```java
private DCLLazyMan (){
        synchronized (DCLLazyMan.class){
            if(dclLazyMan!=null){
                throw new RuntimeException("不要试图通过反射破坏异常");
            }
        }
    }
```

是不是觉得没问题了呢，不你错了，还是能够破坏

只要我们不要通过getInstance()去创建对象

```java
    public static void main(String[] args) throws Exception {
//        DCLLazyMan instance = DCLLazyMan.getInstance();
        Constructor<DCLLazyMan> constructor = DCLLazyMan.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        DCLLazyMan instance2 = constructor.newInstance();
        DCLLazyMan instance = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

又运行成功了。还有人说，那我加一个标志位，进去的时候看有没有跑过构造器，有就抛出异常呗

```java
private static boolean flag = false;
    private DCLLazyMan (){
        synchronized (DCLLazyMan.class){
            if(!flag){
                flag = true;
            }else{
                throw new RuntimeException("不要试图通过反射破坏异常");
            }
        }
    }
```

运行了一下，发现可以，但是我们知道，反射可以拿到你的构造器，那你的变量不是轻而易举就可以拿到

```java
public static void main(String[] args) throws Exception {
//        DCLLazyMan instance = DCLLazyMan.getInstance();
        Constructor<DCLLazyMan> constructor = DCLLazyMan.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        Field flag = DCLLazyMan.class.getDeclaredField("flag");
        DCLLazyMan instance2 = constructor.newInstance();
        flag.set(instance2,false);
        DCLLazyMan instance = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

好了，差不多了，再试下去就破防了

那我们怎么办呢

打开newInstance（）方法，我们可以看到枚举自带单例

![image-20210324115417821](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324115417821.png)

### 4、登记式/静态内部类

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**一般

**描述：**这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域**使用延迟初始化**，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。

```java
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```



### 5、枚举

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易 它更简洁，自动支持序列化机制，绝对防止多次实例化。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线 程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。1 
不能通过 reflection attack 来调用私有构造方法。

```java
public enum  EnumSingle {
    INSTANCE;

    public EnumSingle getInstance(){
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws NoSuchMethodException {
        EnumSingle instance = EnumSingle.INSTANCE;
        
    }
}
```

走到这里我们肯定要试试啦，但是我们发现，我们不知道他调用的构造器是什么，那么我们看看输入的.class文件

![image-20210324120719209](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324120719209.png)

看到了他是执行空参的构造方法

那我们就按照空参的来

```java
public static void main(String[] args) throws Exception {
        EnumSingle instance = EnumSingle.INSTANCE;
        Constructor<EnumSingle> constructor = EnumSingle.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        EnumSingle instance2 = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

一运行，发现不对

![image-20210324120930579](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324120930579.png)

这和我们想的有很大的出入，那也就是说，这里用的不是空参的构造方法

idea骗了我们，那我们试试用cmd能不能得到我们想要的

![image-20210324121232339](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324121232339.png)

然后发现，不能

接下来清楚我们的工具jap

![image-20210324130021722](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130021722.png)

![image-20210324130045929](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130045929.png)

然后我们会发现文件里多了一个东西，打开

![image-20210324130131373](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130131373.png)

终于由我们想要的了，再试试

![image-20210324130249435](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130249435.png)

终于对了



总结一下：

​	 只创建一个对象，同时构造器私有，破坏了七大原则的单一职责



# 工厂模式

## 1、是什么

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

核心本质：

实例化对象不使用new，用工厂方法代替

将选择实现类，创建对象统一管理和控制。从而将**调用者跟我们的实现类解耦**。	



## 2、简单工程模式（静态工厂）

用来生产同一等级结构中的任意产品(对于增加新的产品，需要扩展已有代码

![image-20210329171850817](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329171850817.png)

```java
public interface Car {
    public void name();
}
```

```java
public class TSLA implements Car{
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
```

```java
public class WuLing implements Car{
    @Override
    public void name() {
        System.out.println("五菱");
    }
}	
```

```java
public class CarFactory {

    //方法一
    public Car getCar(String car){
        if(car.equals("五菱")){
            return new WuLing();
        }else if(car.equals("特斯拉")){
            return new TSLA();
        }
        return null;
    }

    //方法二
    public Car getWuLing(){
        return new WuLing();
    }

    public Car getTSLA(){
        return new TSLA();
    }
}
```

这时候如果大众进来了，我们又要对这个工厂进行修改，违背OOP七大原则的第一条：开闭原则



## 3、工厂模式

用来生产同一等级结构中的固定产品(支持增加任意产品)   满足了开闭原则

![image-20210329172208226](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329172208226.png)

```java
public interface Car {
    public void name();
}
```

```java
public class TSLA implements Car {
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
```

```java
public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println("五菱");
    }
}
```

```java
public interface CarFactory {
    public Car getCar();
}
```

```java
public class TesLaFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new TSLA();
    }
}
```

```java
public class WuLingFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new WuLing();
    }
}
```

我们可以很明显的看出，虽然满足了OOP，但是代码量多了很多

所以我们一般是使用静态工厂



## 4、总结

结构复杂度： simple

代码复杂度：simple

编程复杂度：simple

管理上的复杂度： simple



根据设计原则：工厂方法模式

根据实际业务：简单工厂模式



# 抽象工厂

## 1、是什么

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**关键代码：**在一个工厂里聚合多个同类产品。



## 2、举例

![image-20210329172907172](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329172907172.png)

1、产品

```java
public interface IPhoneProduct {
    public void start();

    public void close();

    public void sendMgs();

    public void call();
}
```

```java
public interface IRouterProduct {
    public void start();

    public void close();

    public void openWifi();

    public void setting();
}
```



2、产品族

- 小米

  ```java
  public class XiaomiPhone implements IPhoneProduct{
      @Override
      public void start() {
          System.out.println("小米手机开机了");
      }
  
      @Override
      public void close() {
          System.out.println("小米手机关机了");
      }
  
      @Override
      public void sendMgs() {
          System.out.println("小米手机发信息");
      }
  
      @Override
      public void call() {
          System.out.println("小米手机打电话");
      }
  }
  ```

  

  ```java
  public class XiaomiRouter implements IRouterProduct {
      @Override
      public void start() {
          System.out.println("小米路由器开机了");
      }
  
      @Override
      public void close() {
          System.out.println("小米路由器关机了");
      }
  
      @Override
      public void openWifi() {
          System.out.println("小米路由器打开Wifi");
      }
  
      @Override
      public void setting() {
          System.out.println("小米路由器设置");
      }
  }
  ```

  

- 华为

  ```java
  public class HuaweiPhone implements IPhoneProduct {
      @Override
      public void start() {
          System.out.println("华为手机开机了");
      }
  
      @Override
      public void close() {
          System.out.println("华为手机关机了");
      }
  
      @Override
      public void sendMgs() {
          System.out.println("华为手机发信息");
      }
  
      @Override
      public void call() {
          System.out.println("华为手机打电话");
      }
  }
  ```

  

  ```java
  public class HuaweiRouter implements IRouterProduct {
      @Override
      public void start() {
          System.out.println("华为路由器开机了");
      }
  
      @Override
      public void close() {
          System.out.println("华为路由器关机了");
      }
  
      @Override
      public void openWifi() {
          System.out.println("华为路由器打开Wifi");
      }
  
      @Override
      public void setting() {
          System.out.println("华为路由器设置");
      }
  }
  ```

  

接下来造工厂

```java
public interface ProductFactory {
    public IPhoneProduct getPhone();

    public IRouterProduct getRouter();
}
```

```java
public class XiaomiFactory implements ProductFactory {
    @Override
    public IPhoneProduct getPhone() {
        return new XiaomiPhone();
    }

    @Override
    public IRouterProduct getRouter() {
        return new XiaomiRouter();
    }
}
```

```java
public class HuaweiFactory implements ProductFactory{
    @Override
    public IPhoneProduct getPhone() {
        return new HuaweiPhone();
    }

    @Override
    public IRouterProduct getRouter() {
        return new HuaweiRouter();
    }
}
```

![image-20210329173450203](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329173450203.png)

说白了，就是我们同一个工厂的抽象，在一个更高的纬度去看待问题

但是这里同样破坏了OOP的第一条规则

适用场景:

* 客户端（应用层)不依赖于产品类实例如何被创建、实现等细节
* 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码
* 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现

优点:

* 具体产品在应用层的代码隔离，无需关心创建的细节
* 将一个系列的产品统一到一起创建

缺点:

* 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;
* 增加了系统的抽象性和理解难度



# 建造者模式

## 1、是什么

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**关键代码：**建造者：创建和提供实例，指挥者：管理建造出来的实例的依赖关系。

## 2、测试

就拿房子来举例：大多数房子，都是那几个建造步骤，但有时候顺序可以换一下，这时候就可以使用建造者模式了

![image-20210330095448797](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330095448797.png)

假设造房简化为如下步骤:(1）地基(2）钢筋工程(3）铺电线(4）粉刷；“如果”要盖一座房子，首先要找一个建筑公司或工程承包商(指挥者)。承包商指挥工人(具体建造者）过来造房子(产品)，最后验收。

```java
//产品
public class Product {
    private  String buildA;
    private  String buildB;
    private  String buildC;
    private  String buildD;
    ....(set方法，toString)
}
```

```java
//抽象的建造者
public abstract class Builder {
    abstract void buildA(); //地基
    abstract void buildB(); //钢筋工程
    abstract void buildC(); //铺电线
    abstract void buildD(); //粉刷

    abstract Product getProduct();  //得到东西

}
```

```java
public class Worker extends Builder{

    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    void buildA() {
        product.setBuildA("地基");
        System.out.println("地基");
    }

    @Override
    void buildB() {
        product.setBuildB("钢筋工程");
        System.out.println("钢筋工程");
    }

    @Override
    void buildC() {
        product.setBuildC("铺电线");
        System.out.println("铺电线");
    }

    @Override
    void buildD() {
        product.setBuildD("粉刷");
        System.out.println("粉刷");
    }

    @Override
    Product getProduct() {
        return product;
    }

```

```java
//指挥：核心。
//负责指挥构建一个工程，工程如何建造，由他决定
public class Director {

    //指挥工人按顺序建造房子
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();

        return builder.getProduct();
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Director director = new Director();				//指挥者
        Product product = director.build(new Worker());	//由指挥者指导工人建房子，然后返回房子
        System.out.println(product);
    }
}
```

上面示例是Builder模式的常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。

通过静态内部类方式实现零件无序装配构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品

## 3、实现无指挥者

比如：麦当劳的套餐，服务员〈（具体建造者）可以随意搭配任意几种产品（零件）组成一款套餐（产品)，然后出售给客户。比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。

```java
public abstract class Build {
    abstract Build  putFood(String food);
    abstract Build  putWater(String water);
    abstract Product getProduct();

}
```

```java
//产品
public class Product {
    private String food = "汉堡";
    private String water = "可乐";
    //set()方法和toString()方法
}
```

````java
public class Worker extends Build {

    private Product product;

    public Worker() {
        product = new Product();
    }


    @Override
    Build putFood(String food) {
        product.setFood(food);
        return this;
    }

    @Override
    Build putWater(String water) {
        product.setWater(water);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}
````

```java
public class Consumer {
    public static void main(String[] args) {
        Worker worker = new Worker();
        Product product = worker.putWater("雪碧")
                .putFood("炸鸡")
                .getProduct();

        System.out.println(product);

    }
}
```

因为这里要使用链式编程，所以设定了返回值



## 4、总结

**优点:**
产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。

将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰

具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则“。

**缺点:**

建造者模式所创建的产品一般具有较多的共同点，其组成部分相似;如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。



# 原型模式

## 1、是什么

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**关键代码：** 实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()



## 2、例子

```java
public class Video implements Cloneable {                                    
    private String name;                                                     
    private Date creatTime;                                                  
                                                                             
    @Override                                                                
    protected Object clone() throws CloneNotSupportedException {             
        return super.clone();                                                
    }            
    
    //构造函数，get,set,toString方法
}
```

```java
public class BiliBili {
    public static void main(String[] args) throws CloneNotSupportedException {

        Video v1 = new Video("pwx", new Date());

        System.out.println(v1);
        System.out.println(v1.hashCode());

        Object v2 = v1.clone();
        System.out.println(v2);
        System.out.println(v2.hashCode());
    }
}
```

运行结果

![image-20210330160302610](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330160302610.png)

我们可以看到，这里是两个对象

但是这时候如果我们改了时间

```java
public class BiliBili {
    public static void main(String[] args) throws CloneNotSupportedException {

        Date date = new Date();
        Video v1 = new Video("pwx", date);

        System.out.println(v1);
        System.out.println(v1.hashCode());

        Object v2 = v1.clone();
        System.out.println(v2);
        System.out.println(v2.hashCode());

        date.setTime(1564351845);
        System.out.println(v1);
        System.out.println(v2);
    }
}
```

运行结果：

![image-20210330161818091](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330161818091.png)

我们会发现，这里两个对象的时间都改了，这和我们想要的不一样，这就是浅克隆

![image-20210330161006175](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330161006175.png)

浅克隆就是我们在克隆的时候，我们看到在克隆对象的时候，两个指向的是同一个对象

那试试深克隆

```java
public class Video implements Cloneable {                                    
    private String name;                                                     
    private Date creatTime;                                                  
                                                                             
    @Override                                                   
	protected Object clone() throws CloneNotSupportedException {
    	Object o = super.clone();                               
                                                            
    	//实现深克隆                                                 
    	Video v = (Video) o;                                    
    	//将这个对象的属性也进行克隆~                                        
    	v.creatTime = (Date) this.creatTime.clone();            
                                                            
    	return o;                                               
	}                                                                    
    
    //构造函数，get,set,toString方法
}
```

运行结果

![image-20210330161838768](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330161838768.png)

可以看到，我们在克隆的时候，把对象一起克隆了一个。



## 3、总结

**优点：** 

- 性能提高。 
- 逃避构造函数的约束。

**缺点：** 

- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
- 必须实现 Cloneable 接口。



# 适配器模式

## 1、是什么

<img src="C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330200814236.png" alt="image-20210330200814236" style="zoom:80%;" />

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，适配器是作为网线和笔记本之间的适配器。将网线插入适配器，再将适配器插入笔记本，这样就可以通过笔记本来上网了。



**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 

- 系统需要使用现有的类，而此类的接口不符合系统的需要。
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 
- 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或组合（推荐）。

**关键代码：**适配器继承或组合已有的对象，实现想要的目标接口。



## 2、举例

![image-20210330200649945](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330200649945.png)

拿到首先我们会先创建三个类：电脑，网线，适配器（接口）

之后我们实现适配器实例，同时利用继承，适配网线的方法

之后我们再把适配器放入到电脑中去，这样电脑就是通过适配器调用网线的方法了

思路要清晰

```java
//要被适配的类：网线
public class Adaptee {

    public void request(){
        System.out.println("连接网线上网");
    }
}
```

```java
//接口转换器的抽象实现
public interface NetToUsb {

    //作用，处理请求，网线=>usb
    public void handleRequest();
}
```

```java
//真正的适配器~，需要连接USB，连接网线
//1、继承（类适配器，单继承）
public class Adapter extends Adaptee implements NetToUsb {
    @Override
    public void handleRequest() {
        super.request();    //可以上网了
    }
}
```

```java
//客户端类：想上网，插不上网线
public class Computer {

    public void net(NetToUsb adapter){
        //上网的具体实现，找一个转接头
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑，适配器，网线
        Computer computer = new Computer(); //电脑
        Adaptee adaptee = new Adaptee();    //网线
        Adapter adapter = new Adapter();    //适配器

        computer.net(adapter);
    }
}
```

这是第一种：继承

但是我们知道继承的局限性很大，一般来说我们会使用组合

```java
//真正的适配器~，需要连接USB，连接网线
//2、组合（对象适配器：常用）
public class Adapter2 implements NetToUsb {

    private Adaptee adaptee;		//

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void handleRequest() {
        adaptee.request();    //可以上网了
    }
}
```

```java
//客户端类：想上网，插不上网线
public class Computer {

    public void net(NetToUsb adapter){
        //上网的具体实现，找一个转接头
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑，适配器，网线
        Computer computer = new Computer();//电脑
        Adaptee adaptee = new Adaptee();    //网线
        Adapter2 adapter2 = new Adapter2(adaptee);    //适配器

        computer.net(adapter2);
    }
}
```

这就大大降低了耦合性



## 3、总结

> 优点

- 一个适配器可以把多个不同的适配器适配到同一个目标
- 可以适配一个是适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏替换原则”，适配者的子类也可以通过该适配器进行适配

> 缺点

- 对于Java等单继承语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。这也是我们为什么提倡用组合而不用继承的原因



# 桥接模式

## 1、是什么

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

![image-20210307205047982](file://C:\Users\86796\Desktop\java资料\设计模式\设计模式.assets\image-20210307205047982.png?lastModify=1617108118)

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**关键代码：**抽象类依赖实现类。

![image-20210307205302746](file://C:\Users\86796\Desktop\java资料\设计模式\设计模式.assets\image-20210307205302746.png?lastModify=1617108157)

这样就可以实现解耦了



## 2、举例

![image-20210307223607516](file://C:\Users\86796\Desktop\java资料\设计模式\设计模式.assets\image-20210307223607516.png?lastModify=1617108641)

```java
//牌子
public interface Brand {
    void info();
}
```

```java
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.println("苹果");
    }
}
```

```java
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.println("联想");
    }
}
```

```java
public abstract class Computer {
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info(){
        brand.info();
    }
}

// 台式机
class DeskTop extends Computer{
    public DeskTop(Brand brand) {
        super(brand);
    }

    public void info(){
        super.info();
        System.out.println("台式机");
    }
}

//笔记本
class LapTop extends Computer{
    public LapTop(Brand brand) {
        super(brand);
    }

    public void info(){
        super.info();
        System.out.println("笔记本");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Computer lapTop = new LapTop(new Apple());
        lapTop.info();

        Computer deskTop = new DeskTop(new Lenovo());
        deskTop.info();
    }
}
```

其实我们发现了桥接模式和适配器模式有一个共同点，都是通过组合把这两个不相关的类联系起来的



## 3、总结

**好处分析:**

桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多、桥接模式是比多继承方案更好的解决方法。极大的减少了子类的个数，从而降低管理和维护的成本

桥接模式提高了系统的可扩充性(在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符令开闭原则，**就像一座桥，可以把两个变化的维度连接起来!**

**劣势分析:**

桥接模式的引人会增加系统的理解与设计难度由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。







# 过滤器模式

## 1、是什么

过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

![image-20210331100203809](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210331100203809.png)

这个模式比较好理解



## 2、举例



![image-20210331095713296](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210331095713296.png)

定义一个具体要过滤的对象

```java
public class Person {
    private String name;            //名字
    private String gender;          //性别
    private String maritalStatus;   //婚宴状况

	//构造函数，get方法，toString方法
}
```

过滤接口

```java
//过滤的标准
public interface Criteria {

    List<Person> meetCriteria(List<Person> persons);
}
```

过滤器实例

```java
//过滤出来单身的
public class CriteriaSingle implements Criteria {
    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> singlePersons = new ArrayList<Person>();
        for (Person person : persons) {
            if(person.getMaritalStatus().equalsIgnoreCase("SINGLE")){
                singlePersons.add(person);
            }
        }
        return singlePersons;
    }
}
```

```java
//过滤出来是男的
public class CriteriaMale implements Criteria {
    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> malePersons = new ArrayList<Person>();
        for (Person person : persons) {
            //忽略大小写
            if(person.getGender().equalsIgnoreCase("MALE")){
                malePersons.add(person);
            }
        }
        return malePersons;
    }
}
```

```java
public class CriteriaFemale implements Criteria {
    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> malePersons = new ArrayList<Person>();
        for (Person person : persons) {
            //忽略大小写
            if(person.getGender().equalsIgnoreCase("FEMALE")){
                malePersons.add(person);
            }
        }
        return malePersons;
    }
}
```

交集和并集

```java
//并集
public class AndCriteria implements Criteria {

    private Criteria criteria;
    private Criteria otherCriteria;

    public AndCriteria(Criteria criteria, Criteria otherCriteria) {
        this.criteria = criteria;
        this.otherCriteria = otherCriteria;
    }

    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);
        return otherCriteria.meetCriteria(firstCriteriaPersons);
    }
}
```

```java
//交集
public class OrCriteria implements Criteria{

    private Criteria criteria;
    private Criteria otherCriteria;

    public OrCriteria(Criteria criteria, Criteria otherCriteria) {
        this.criteria = criteria;
        this.otherCriteria = otherCriteria;
    }

    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);
        List<Person> otherCriteriaPersons = otherCriteria.meetCriteria(persons);

        for (Person person : firstCriteriaPersons) {
            if(!otherCriteriaPersons.contains(person)){
                otherCriteriaPersons.add(person);
            }
        }
        return otherCriteriaPersons;
    }
}
```

MyTest

```java
public class MyTest {
    public static void main(String[] args) {
        List<Person> persons = new ArrayList<Person>();

        persons.add(new Person("Pwx","Male", "Single"));
        persons.add(new Person("Robert","Male", "Single"));
        persons.add(new Person("John","Male", "Married"));
        persons.add(new Person("Laura","Female", "Married"));
        persons.add(new Person("Diana","Female", "Single"));
        persons.add(new Person("Mike","Male", "Single"));
        persons.add(new Person("Bobby","Male", "Single"));

        Criteria male = new CriteriaMale();
        Criteria female = new CriteriaFemale();
        Criteria single = new CriteriaSingle();
        Criteria singleMale = new AndCriteria(single, male);
        Criteria singleFemale = new OrCriteria(single, female);

        System.out.println("Males: ");
        List<Person> malesPeople = male.meetCriteria(persons);
        for (Person person : malesPeople) {
            System.out.println(person);
        }

        System.out.println("Female: ");
        List<Person> femalesPeople = female.meetCriteria(persons);
        for (Person person : femalesPeople) {
            System.out.println(person);
        }

        System.out.println("SingleMale: ");
        List<Person> singleMalePeople = singleMale.meetCriteria(persons);
        for (Person person : singleMalePeople) {
            System.out.println(person);
        }

        System.out.println("singleFemale: ");
        List<Person> singleFemalePeople = singleFemale.meetCriteria(persons);
        for (Person person : singleFemalePeople) {
            System.out.println(person);
        }
    }
}
```





# 组合模式

## 1、是什么

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 

- 您想表示对象的部分-整体层次结构（树形结构）。 
- 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。

**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

2、举例

![image-20210331103958230](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210331103958230.png)

回去看看定义，所有的人都是员工，然后再对员工进行组合成树状，形成一个有层次的对象组

```java
public class Employee {
    private String name;                    //名字
    private String dept;                    //住址
    private int salary;                     //工资
    private List<Employee> subordinates;    //下属

    public Employee(String name, String dept, int salary) {
        this.name = name;
        this.dept = dept;
        this.salary = salary;
        subordinates = new ArrayList<>();
    }

    //添加一个下属
    public void add(Employee e) {
        subordinates.add(e);
    }

    //移除一个下属
    public void remove(Employee e) {
        subordinates.remove(e);
    }

    //获取所有下属
    public List<Employee> getSubordinates(){
        return subordinates;
    }

    public String toString(){
        return ("Employee :[ Name : "+ name
                +", dept : "+ dept + ", salary :"
                + salary+" ]");
    }
}
```

```java
public class CompositeTest {
    public static void main(String[] args) {
        Employee CEO = new Employee("John","CEO", 30000);

        Employee headSales = new Employee("Robert","Head Sales", 20000);

        Employee headMarketing = new Employee("Michel","Head Marketing", 20000);

        Employee clerk1 = new Employee("Laura","Marketing", 10000);
        Employee clerk2 = new Employee("Bob","Marketing", 10000);

        Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
        Employee salesExecutive2 = new Employee("Rob","Sales", 10000);

        CEO.add(headSales);
        CEO.add(headMarketing);

        headSales.add(salesExecutive1);
        headSales.add(salesExecutive2);

        headMarketing.add(clerk1);
        headMarketing.add(clerk2);

        //打印该组织的所有员工
        System.out.println(CEO);
        for (Employee headEmployee : CEO.getSubordinates()) {
            System.out.println(headEmployee);
            for (Employee employee : headEmployee.getSubordinates()) {
                System.out.println(employee);
            }
        }
    }
}
```

这样下来，我们会发现，整个类非常的有层次感



## 3、总结

优点：

- 高层模块调用简单。 
- 节点自由增加。

缺点：

- 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

# 代理模式

Spring AOP



# 装饰器模式

## 1、是什么

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**关键代码：** 1、Component 类充当**抽象**角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。



## 2、举例

![image-20210401165317839](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210401165317839.png)



Shape接口

```java
//定义一个图形
public interface Shape {
    public void draw();
}
```

```java
//定义一个圆
public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Shape--> Circle");
    }
}
```

```java
//定义一个矩形
public class Rectangle implements Shape{

    @Override
    public void draw() {
        System.out.println("Shape-->Rectangle");
    }
}
```



抽象修饰类

```java
public abstract class ShapeDecorator implements Shape {

    protected Shape shape;

    public ShapeDecorator(Shape shape) {
        this.shape = shape;
    }

    @Override
    public void draw() {
        shape.draw();
    }
}
```

```java
//创建扩展了 ShapeDecorator 类的实体装饰类。
public class RedShapeDecorator extends ShapeDecorator {
    public RedShapeDecorator(Shape shape) {
        super(shape);
    }

    @Override
    public void draw() {
        shape.draw();
        setRedBorder(shape);
    }

    private void setRedBorder(Shape shape){
        System.out.println("Border Color: Red");
    }
}
```

Test

```java
public class MyTest {
    public static void main(String[] args) {
        Shape circle = new Circle();
        ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
        ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
        //Shape redCircle = new RedShapeDecorator(new Circle());
        //Shape redRectangle = new RedShapeDecorator(new Rectangle());
        System.out.println("Circle with normal border");
        circle.draw();

        System.out.println("\nCircle of red border");
        redCircle.draw();

        System.out.println("\nRectangle of red border");
        redRectangle.draw();
    }
}
```



## 3、总结

**优点：**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**缺点：**多层装饰比较复杂。



对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。

对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。

他们之间的边界确实比较模糊，两者都是对类的方法进行扩展，具体区别如下：

1、装饰器模式强调的是**增强自身**，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让**别人**帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。

2、装饰模式是以对客户端透明的方式扩展对象的功能，是**继承**方案的一个替代方案；代理模式则是给一个对象**提供一个代理对象**，并由代理对象来控制对原有对象的引用；

3、装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；



# 外观模式

## 1、是什么

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性，说白了，就是加一层

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

**意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**主要解决：**降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。

**何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。

**如何解决：**客户端不与系统耦合，外观类与系统耦合。

**关键代码：**在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

**应用实例：** JAVA 的三层开发模式。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3BwZHh6ei9pbWFnZXMvbWFzdGVyL2ltZy9QaWNHby1HaXRodWItUGljQmVkLzIwMjAwNDI4MTMzNjQ5LnBuZw?x-oss-process=image/format,png)

## 2、举例

![image-20210401180809061](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210401180809061.png)

Shape还是和装饰器模式一样

然后定义一个ShapeMaker，统一管理Shape

```java
public class ShapeMaker {
    private Shape circle;
    private Shape rectangle;
    private Shape square;

    public ShapeMaker() {
        circle = new Circle();
        rectangle = new Rectangle();
        square = new Square();
    }

    public void drawCircle(){
        circle.draw();
    }
    public void drawRectangle(){
        rectangle.draw();
    }
    public void drawSquare(){
        square.draw();
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        ShapeMaker shapeMaker = new ShapeMaker();

        shapeMaker.drawCircle();
        shapeMaker.drawRectangle();
        shapeMaker.drawSquare();
    }
}
```



## 3、总结

优点：

降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类，满足“迪米特法则”

对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。

降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

缺点：

增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。




# 享元模式

## 1、是什么

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试**重用**现有的同类对象，如果未找到匹配的对象，则创建新对象。



**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**在有大量对象时，有可能会造成内存溢出（OOM），我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

**关键代码：**用 HashMap 存储这些对象。

**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。



## 2、举例

![image-20210401191927518](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210401191927518.png)

颜色是共同的，而且是有限的，所以把他抽出来，所谓分组的条件

```java
public interface Shape {
    void draw();
}
```

```java
public class Circle implements Shape {
    private String color;
    private int x;
    private int y;
    private int radius;

    public Circle(String color){
        this.color = color;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Circle: Draw() [Color : " + color
                +", x : " + x +", y :" + y +", radius :" + radius);
    }
}
```

核心：HashMap存储对象

```java
public class ShapeFactory {
    private static final HashMap<String, Shape> circleMap = new HashMap<>();

    public static Shape getCircle(String color) {
        Circle circle = (Circle)circleMap.get(color);

        if(circle == null) {
            circle = new Circle(color);
            circleMap.put(color, circle);
            System.out.println("Creating circle of color : " + color);
        }
        return circle;
    }

    public static int size(){
        return circleMap.size();
    }
}
```

测试

```java
public class MyTest {
    private static final String[] colors =
            { "Red", "Green", "Blue", "White", "Black" };
    public static void main(String[] args) {

        for(int i=0; i < 20; ++i) {
            Circle circle =
                    (Circle)ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
        System.out.println(ShapeFactory.size());
    }
    private static String getRandomColor() {
        return colors[(int)(Math.random()*colors.length)];
    }
    private static int getRandomX() {
        return (int)(Math.random()*100 );
    }
    private static int getRandomY() {
        return (int)(Math.random()*100);
    }
}
```

分组，共享对象



## 3、总结

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。







# 命令模式

## 1、是什么

命令模式是一种数据驱动的设计模式，它属于行为型模式。

请求以命令的形式包裹在对象中，并传给调用对象

调用对象寻找可以处理该命令的合适对象，并把该命令传给相应的对象，该对象执行命令



**意图：**将一个请求封装成一个对象，从而是你可以用不同的请求对客户进行形参化。对**行为请求和行为实现实现了解耦**





## 2、举例

![image-20210402104728597](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210402104728597.png)

定义一个命令

```java
//命令
public interface Order {
    public void execute();
}
```

定义请求

```java
//请求
public class Stock {
    private String name = "ABC";
    private int quantity = 10;


    public void buy(){
        System.out.println("Stock----->buy");
        System.out.println("Name:"+name+","+"quantity:"+quantity);
    }

    public void sell(){
        System.out.println("Stock----->sell");
        System.out.println("Name:"+name+","+"quantity:"+quantity);
    }
}
```

对请求实现封装

```java
//买的命令
public class BuyStock implements Order {
    private Stock stock;

    public BuyStock(Stock stock) {
        this.stock = stock;
    }

    @Override
    public void execute() {
        stock.buy();
    }
}
```

```java
//卖的命令
public class SellStock implements Order {
    private Stock stock;

    public SellStock(Stock stock) {
        this.stock = stock;
    }

    @Override
    public void execute() {
        stock.sell();
    }
}
```

这就完成了对请求的封装

然后是调用

```java
public class Broket {
    private List<Order> orders = new ArrayList<>();

    public void takeOrder(Order order){
        orders.add(order);
    }

    public void placeOrders(){
        for (Order order : orders) {
            order.execute();
        }

        orders.clear();
    }
}
```

这里我们把请求所封装成的对象`order`传给调用者，调用者再通过具体的命令去实现具体的请求

```java
public class MyTest {
    public static void main(String[] args) {
        Stock stock = new Stock();
        BuyStock buyStock = new BuyStock(stock);
        SellStock sellStock = new SellStock(stock);

        Broket broket = new Broket();
        broket.takeOrder(buyStock);
        broket.takeOrder(sellStock);

        broket.placeOrders();
    }
}
```



## 3、总结

优点：

- 降低了系统的耦合
- 新的请求很容易添加到系统中去

缺点：

- 当请求过多的时候，可能会产生大量的具体命令



# 责任链模式

## 1、是什么

顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，**对请求的发送者和接收者进行解耦**。这种类型的设计模式属于行为型模式。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

**何时使用：**在处理消息的时候以过滤很多道。

**如何解决：**拦截的类都实现**统一接口**。

**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。



## 2、举例

![image-20210408145358184](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210408145358184.png)

这个模式的首要思想是创造一条处理链。创造之前先写一个统一接口

```java
//抽象的记录类
public abstract class AbstractLogger {
    public static int INFO = 1;
    public static int DEBUG = 2;
    public static int ERROR = 3;
    
    protected int level;
    
    //责任链的下一个元素
    protected AbstractLogger nextLogger;

    public void setNextLogger(AbstractLogger nextLogger) {
        this.nextLogger = nextLogger;
    }
    
    abstract protected void write(String message);
        
    public void logMessage(int level,String message){
        if(this.level<=level){
            write(message);
        }
        
        if(nextLogger != null){
            nextLogger.logMessage(level,message);
        }
    }
}
```

然后实现接口

```java
public class ErrorLogger extends AbstractLogger {
    public ErrorLogger(int level) {
        this.level = level;
    }

    @Override
    public void write(String message) {
        System.out.println("Error:"+message);
    }
}
```

```java
public class ConsoleLogger extends AbstractLogger {

    public ConsoleLogger(int level) {
        this.level = level;
    }

    @Override
    public void write(String message) {
        System.out.println("Standard Console:"+message);
    }
}
```

```java
public class FileLogger extends AbstractLogger {

    public FileLogger(int level) {
        this.level = level;
    }

    @Override
    public void write(String message) {
        System.out.println("file:"+message);
    }
}
```



接下来创建请求处理链

```java
public class MyTest {

    //设计一条链出来
    private static AbstractLogger getChainOfLogger(){
        AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);     //3
        AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);       //2
        AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);  //1

        errorLogger.setNextLogger(fileLogger);
        fileLogger.setNextLogger(consoleLogger);

        return errorLogger;
    }

    public static void main(String[] args) {
        AbstractLogger chain = getChainOfLogger();
        chain.logMessage(AbstractLogger.INFO,"This is an information");
        chain.logMessage(AbstractLogger.DEBUG, "This is a debug level information.");
        chain.logMessage(AbstractLogger.ERROR, "This is an error information.");

    }

}
```



## 3、总结

**优点：** 

- 降低耦合度。它将请求的发送者和接收者解耦。 
- 简化了对象。使得对象不需要知道链的结构。 
- 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 
- 增加新的请求处理类很方便。

**缺点：** 

- 不能保证请求一定被接收。 
- 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
- 可能不容易观察运行时的特征，有碍于除错。



# 解释器模式

## 1、是什么

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。

说白了，就是定义一句话，然后去设计实现这句话

这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。

解释器模式包含以下主要角色。

- 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
- 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
- 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
- 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
- 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。



## 2、举例

![image-20210408221411995](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210408221411995.png)

```java
//创建一个表达式接口。
public interface Expression {

    public boolean interpret(String context);   //解释方法

}
```



```java
//终结符表达式类
public class TerminalExpression implements Expression {

    private String data;

    public TerminalExpression(String data) {
        this.data = data;
    }

    @Override
    public boolean interpret(String context) {
        //对终结符表达式的处理
        if(context.contains(data)){
            return true;
        }
        return false;
    }
}
```



```java
//非终结符表达式类
public class AndExpression implements Expression {

    private Expression expression = null;
    private Expression expression2 = null;

    public AndExpression(Expression expression, Expression expression2) {
        this.expression = expression;
        this.expression2 = expression2;
    }

    @Override
    public boolean interpret(String context) {
        return expression.interpret(context) && expression2.interpret(context);
    }
}
```



```java
public class OrExpression implements Expression {

    private Expression expression = null;
    private Expression expression2 = null;

    public OrExpression(Expression expression, Expression expression2) {
        this.expression = expression;
        this.expression2 = expression2;
    }

    @Override
    public boolean interpret(String context) {
        return expression.interpret(context) || expression2.interpret(context);
    }
}
```



然后用户来定义上下文

```java
public class MyTest {

    //创建两个Context
    //规则：Robert 和 John 是男性
    public static Expression getMaleExpression(){
        Expression robert = new TerminalExpression("Robert");
        Expression john = new TerminalExpression("John");
        return new OrExpression(robert, john);
    }

    //规则：Julie 是一个已婚的女性
    //<expression> ::= <已婚>的<女性>
    public static Expression getMarriedWomanExpression(){
        Expression julie = new TerminalExpression("Julie");
        Expression married = new TerminalExpression("Married");
        return new AndExpression(julie, married);
    }

    public static void main(String[] args) {
        Expression isMale = getMaleExpression();
        Expression isMarriedWoman = getMarriedWomanExpression();

        System.out.println("John is male? " + isMale.interpret("John"));
        System.out.println("Julie is a married women? "
                + isMarriedWoman.interpret("Married Julie"));
    }
}
```



## 3、总结

**优点：**

- 可扩展性比较好，灵活。 
- 增加了新的解释表达式的方式。 
- 易于实现简单文法。

**缺点：** 

- 可利用场景比较少。 
- 对于复杂的文法比较难维护。 
- 解释器模式会引起类膨胀。 
- 解释器模式采用递归调用方法。





# 迭代器模式

## 1、是什么

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

迭代器模式属于行为型模式。



  这种模式，我们在大量的容器里面可以看到这种应用，简单的提供一种方法，访问一个容器里面的各个元素，又无需暴露对象的内部表示，保证了数据安全。满足“单一职责原则”和“开闭原则”



**关键代码：**定义接口：hasNext, next。



迭代器模式主要包含以下角色。

- 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
- 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
- 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
- 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。



## 2、举例

```java
//迭代器
public interface Iterator {
    public boolean hasNext();
    public Object next();
}
```



```java
//容器
public interface Container {
    public Iterator getIterator();
}
```



这里可以把这个迭代器单独拿出来，我只是为了偷懒

```java
public class NameRepository implements Container{

    public String[] names = {"Robert" , "John" ,"Julie" , "Lora"};

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator {

        int index;

        @Override
        public boolean hasNext() {
            if(index<names.length){
                return true;
            }
            return false;
        }

        @Override
        public Object next() {
            if(this.hasNext()){
                return names[index++];
            }
            return null;
        }
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        NameRepository nameRepository = new NameRepository();


        for(Iterator iterator = nameRepository.getIterator();iterator.hasNext();){
            String name = (String) iterator.next();
            System.out.println("Name:"+name);
        }
    }
}
```



## 3、总结

**优点：** 

- 它支持以不同的方式遍历一个聚合对象。
- 迭代器简化了聚合类。
- 在同一个聚合上可以有多个遍历。 
- 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

**缺点：**

- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。





# 中介者模式

## 1、是什么

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，且可以独立地改变它们之间的交互，使代码易于维护。中介者模式又叫调停模式，它是迪米特法则的典型应用。



在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。

如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。

![image-20210409105654113](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210409105654113.png)

在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。



## 2、举例

![image-20210409144333774](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210409144333774.png)

这里由于想要偷懒，就不对中介者进行面向接口编程了

```java
//创建中介类。
public class ChatRoom {
    public static void showMessage(User user, String message){
        System.out.println(new Date().toString()
                + " [" + user.getName() +"] : " + message);
    }
}
```



```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void sendMessage(String message){
        ChatRoom.showMessage(this,message);
    }
}
```





```java
public class MyTest {
    public static void main(String[] args) {
        User robert = new User("Robert");
        User john = new User("John");

        robert.sendMessage("Hi! John!");
        john.sendMessage("Hello! Robert!");
    }
}
```

一顿操作下来，我们发现，说白了，就是利用一个中介类，然后对具体实例使用中介类的方法，从而达到解耦的目的

听名字有点像静态代理，但实则不然，要注意区分



## 3、总结

**优点：** 

- 降低了类的复杂度，将**一对多**转化成了**一对一**。 
- 各个类之间的解耦。 
- 符合迪米特原则。

**缺点：**中介者会庞大，变得复杂难以维护。



# 备忘录模式

## 1、是什么

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。

备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。



备忘录模式的主要角色如下。

- 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
- 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
- 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。



## 2、举例

备忘录

```java
public class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}
```



然后创建发起者，创建备忘录

```java
public class Originator {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento saveStateToMemento(){
        return new Memento(state);
    }

    public void getStateFromMemento(Memento memento){
        state = memento.getState();
    }
}
```



然后创建管理者，管理这些备忘录

```java
public class CareTaker {
    private List<Memento> list = new ArrayList<>();

    public void add(Memento memento){
        list.add(memento);
    }

    public Memento get(int index){
        return list.get(index);
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();
        originator.setState("State #1");
        originator.setState("State #2");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #3");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #4");

        System.out.println("Current State: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(0));
        System.out.println("First saved State: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(1));
        System.out.println("Second saved State: " + originator.getState());
    }
}
```



这样既完成了备份，同时又保证了数据安全



## 3、总结

优点

- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合**单一职责**原则。


缺点：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。



# 观察者模式

## 1、是什么

指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式

他解决了一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低藕性，保证高度的协作

**关键代码：**在抽象类里有一个 ArrayList 存放观察者们。





## 2、举例

```java
//目标类
//它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
public class Subject {
    private List<Observer> list = new ArrayList<>();

    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
    }

    public void attach(Observer observer){
        list.add(observer);
    }

    public void notifyAllObserver(){
        for (Observer observer : list) {
            observer.update();
        }
    }
}
```

```java
//观察者
public interface Observer {
    public void update();
}
```

```java
public class BinaryObserver implements Observer{
    private Subject subject;

    public BinaryObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Binary String: "
                + Integer.toBinaryString( subject.getState() ) );
    }
}
```

```java
public class HexaObserver implements Observer{
    private Subject subject;

    public HexaObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Hex  String: "
                + Integer.toHexString( subject.getState() ) );
    }
}
```

```java
public class OctalObserver implements Observer{
    private Subject subject;

    public OctalObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Octal String: "
                + Integer.toOctalString( subject.getState() ) );
    }
}
```

```java
public class MyTest {
    public static void main(String[] args) {
        Subject subject = new Subject();

        new BinaryObserver(subject);
        new HexaObserver(subject);
        new OctalObserver(subject);

        System.out.println("First state change: 15");
        subject.setState(15);
        subject.notifyAllObserver();
        System.out.println("Second state change: 10");
        subject.setState(10);
        subject.notifyAllObserver();
    }
}
```



## 3、总结

优点：

- 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合**依赖倒置**原则。
- 目标与观察者之间建立了一套触发机制。

缺点

- 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
- 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。



# 状态模式

## 1、是什么

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。



状态模式包含以下主要角色。

- 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
- 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
- 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。



## 2、举例

```java
public interface State {
    public void doAction(Context context);
}
```



```java
//它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
public class Context {
    private State state;

    public Context(){
        state = null;
    }

    public void setState(State state){
        this.state = state;
    }

    public State getState(){
        return state;
    }
}
```



```java
public class StartState implements State {
    @Override
    public void doAction(Context context) {
        System.out.println("Player is in start state");
        context.setState(this);
    }

    public String toString(){
        return "Start State";
    }

}
```

```java
public class StopState implements State {
    @Override
    public void doAction(Context context) {
        System.out.println("Player is in stop state");
        context.setState(this);
    }

    public String toString(){
        return "Stop State";
    }

}
```



```java
public class MyTest {
    public static void main(String[] args) {
        Context context = new Context();

        StartState startState = new StartState();
        startState.doAction(context);

        System.out.println(context.getState().toString());

        StopState stopState = new StopState();
        stopState.doAction(context);

        System.out.println(context.getState().toString());
    }

}
```



## 3、总结

优点

1. 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“**单一职责原则**”。
2. 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
3. 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。


状态模式的主要缺点如下。

1. 状态模式的使用必然会增加系统的类与对象的个数。
2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
3. 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。



# 策略模式

## 1、是什么

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。

当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。

如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。

该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的**责任**和算法的**实现**分割开来，并委派给不同的对象对这些算法进行管理。

所以我们很容易得出，这个算法里面有三个角色

- 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
- 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
- 环境（Context）类：持有一个策略类的引用，最终给客户端调用。



## 2、举例

透过引用调用对象

```java
public interface Strategy {
    public int doOperation(int num1,int num2);
}
```

```java
public class OperationAdd implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1+num2;
    }
}
```

```java
public class OperationMultiply implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1*num2;
    }
}
```

```java
public class OperationSubtract implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1-num2;
    }
}
```

引用

```java
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public int execute(int num1,int num2){
        return strategy.doOperation(num1,num2);
    }
}
```





```java
public class MyTest {
    public static void main(String[] args) {
        Context context = new Context(new OperationAdd());
        System.out.println("10+5="+context.execute(10,5));

        context = new Context(new OperationMultiply());
        System.out.println("10*5="+context.execute(10,5));

        context = new Context(new OperationSubtract());
        System.out.println("10-5="+context.execute(10,5));
    }
}
```



## 3、总结

优点

- 多重条件语句不易维护，而使用策略模式可以**避免使用多重条件**语句，如 if...else 语句、switch...case 语句。
- 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
- 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
- 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
- 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。


缺点

1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
2. 策略模式造成很多的策略类，增加维护难度。



# 模板模式

## 1、是什么

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

举个简单的例子：去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。



所以不难发现，我们在这里只有两个角色

- 抽象的父类：把子类所有共同的东西在父类实现，定下框架，具体细节交给子类各自进行实现
- 子类：对父类中的抽象方法进行各自的重写



## 2、举例

这里举一个游戏的例子，所有的游戏都是按照初始化，开始，结束的流程走，但是他们三个的每一步都有自己的实现方式，所以放到子类去实现，但是流程是一样的，所以放在了父类去实现；

```java
public abstract class Game {
    abstract void initialize();
    abstract void startPlay();
    abstract void endPlay();

    //模板
    public final void play(){

        //初始化游戏
        initialize();

        //开始游戏
        startPlay();

        //结束游戏
        endPlay();
    }
}
```



```java
public class Football extends Game {
    @Override
    void initialize() {
        System.out.println("Football Game Initialized! Start playing.");
    }

    @Override
    void startPlay() {
        System.out.println("Football Game Started. Enjoy the game!");
    }

    @Override
    void endPlay() {
        System.out.println("Football Game Finished!");
    }
}
```

```java
public class Cricket extends Game {
    @Override
    void initialize() {
        System.out.println("Cricket Game Initialized! Start playing.");
    }

    @Override
    void startPlay() {
        System.out.println("Cricket Game Started. Enjoy the game!");
    }

    @Override
    void endPlay() {
        System.out.println("Cricket Game Finished!");
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        Game game = new Cricket();
        game.play();
        System.out.println("=====================");
        game = new Football();
        game.play();
    }
}
```



## 3、总结

**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。



# 访问者模式

## 1、是什么

在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。

访问者模式包含以下主要角色。

1. 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
2. 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
3. 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
4. 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
5. 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。



## 2、举例

一个更好的理解，就是相当于我们通过不同的方式去看代不同的东西，就可以得到不同的答案

我们通过不同的观察者，去实现元素的方法，自然就会得到不同的结果

![image-20210410120429728](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210410120429728.png)

元素接口

```java
public interface ComputerPart {
    public void accept(ComputerPartVisitor computerPartVisitor);
}
```



```java
public class Mouse implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}
```

```java
public class Monitor implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}
```

```java
public class Keyboard implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}
```



访问者接口

```java
public interface ComputerPartVisitor {
    public void visit(Computer computer);
    public void visit(Mouse mouse);
    public void visit(Keyboard keyboard);
    public void visit(Monitor monitor);
}
```

```java
public class ComputerPartDisplayVisitor implements ComputerPartVisitor {
    @Override
    public void visit(Computer computer) {
        System.out.println("Displaying Computer.");
    }

    @Override
    public void visit(Mouse mouse) {
        System.out.println("Displaying Mouse.");
    }

    @Override
    public void visit(Keyboard keyboard) {
        System.out.println("Displaying Keyboard.");
    }

    @Override
    public void visit(Monitor monitor) {
        System.out.println("Displaying Monitor.");
    }
}
```



对象结构

```java
public class Computer implements ComputerPart {

    ComputerPart[] parts;

    public Computer(){
        parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};
    }


    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        for (int i = 0; i < parts.length; i++) {
            parts[i].accept(computerPartVisitor);
        }
        computerPartVisitor.visit(this);
    }
}
```



通过访问者访问元素

```java
public class MyTest {
    public static void main(String[] args) {

        ComputerPart computer = new Computer();
        computer.accept(new ComputerPartDisplayVisitor());
    }
}
```



## 3、总结

优点

1. 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
2. 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
3. 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
4. 符合**单一职责**原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。


缺点

1. 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
2. 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
	3. 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。