# 设计模式之美

# 编写高质量代码

![img](.\设计模式之美.assets\f3262ef8152517d3b11bfc3f2d2b12d3.png)

关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系我总结梳理一下。

- 面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。
- 设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。
- 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。
- 编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。
- 重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。



# 什么是面向对象

1. 什么是面向对象编程？

   面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

2.  什么是面向对象编程语言？

   面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

3. 如何判定一个编程语言是否是面向对象编程语言？

   如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。

4. 面向对象编程和面向对象编程语言之间有何关系？

   面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

5. 什么是面向对象分析和面向对象设计？

   简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。



# 封装、抽象、继承、多态

## 封装

> 是什么

封装也叫作信息隐藏或者数据访问保护。



> 怎么实现

类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制



> 为什么

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。

如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。

相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。



## 抽象

> 是什么

抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。



> 怎么实现

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

这个很好理解，比如下面这个接口

```java
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

对于这个接口类，我们不用管他具体的实现方式，只需要知道他有什么方法（当然，具体到开发，建议稍微看看，防止被坑）

实际上，我们甚至可以不要这个接口类（IPictureStorage），对于单纯的 PictureStorage 类本身就满足抽象特性。

因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。

通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。

比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。

所以，这也就是为什么抽象他并不是面向对象的特性之一，因为他仅需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性



> 为什么

其实在开发过程中，我们往往需要调一下其他的接口，我们需要用到他，但是对区其具体的实现并不是很在意，这些对我们来说，就是一些非关键性的实现细节，而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。

很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。

举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。



## 继承

> 是什么

继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物

。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。

- 单继承表示一个子类只继承一个父类
- 多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。



> 怎么实现

对于Java来说，java使用 extends 关键字来实现继承，并只能实现单继承

但是对于C++来说，确实可以实现多继承的。



> 为什么

继承最大的一个好处就是代码复用。

假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。

这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。

不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。

对于继承来说，他是非常符合我们人类的思维，比如猫属于哺乳动物，对于我们来说，是一种is a 的关系

继承的概念很好理解，也很容易使用。

不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。

为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。

还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。

所以这也就是为什么一直在倡导多组合少继承，这个问题我们往后看



## 多态

> 是什么

多态是指，子类可以替换父类



> 怎么实现

在实际的代码运行过程中，调用子类的方法实现。

这个其实我们举一个例子看一下就明白了

比如动物的叫声，对于羊来说，是咩咩咩；对于狗来说，就是汪汪汪；这其实就是多态的表现形式

看一个具体的例子

```java
public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

多态这种特性也需要编程语言提供特殊的语法机制来实现。

- 第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。
- 第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。
- 第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。

对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法（python）。



接下来，我们先来看如何利用接口类来实现多态特性。

```java
public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。

Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。

duck-typing因为本人对python不熟悉，在这里就不展开描述了。



> 为什么

多态特性能提高代码的可扩展性和复用性。

像上面的例子中，我们仅用一个print就完成了Array和LinkedList的打印；

如果用的不是多态的特性，我们就要分别进行实现，针对每一种集合都要写一个print方法

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。



## 总结

1. 关于封装特性
   - 封装也叫作信息隐藏或者数据访问保护。
   - 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。
   - 它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。
   - 封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；
   - 另一方面是仅暴露有限的必要接口，提高类的易用性。
2. 关于抽象特性
   - 抽象讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。
   - 抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。
   - 抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；
   - 另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
3. 关于继承特性
   - 继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。
   - 单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。
   - 为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。
4. 关于多态特性
   - 多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。
   - 多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。
   - 多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。



# 面向过程和面向对象

其实在开发过程中，我们虽然用的是面向对象的语言，但是在实际开发中，实际上是在编写面对过程的代码

所以我们通过以下几个问题，来对比一下，这两者的区别：

- 什么是面向过程编程与面向过程编程语言？
- 面向对象编程相比面向过程编程有哪些优势？
- 为什么说面向对象编程语言比面向过程编程语言更高级？
- 有哪些看似是面向对象实际是面向过程风格的代码？
- 在面向对象编程中，为什么容易写出面向过程风格的代码？
- 面向过程编程和面向过程编程语言就真的无用武之地了吗？



## 什么是面向过程编程与面向过程编程语言

我相信很多人接触的第一门语言，都是C，所以对面向过程这个概念应该都不陌生

我们回顾以下面向对象的定义

- 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。
- 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

那么我们用同样的方式定义以下面对过程（非官方）

- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。
- 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

简单的看一下下面这个例子

假设我们有一个记录了用户信息的文本文件 users.txt，每行文本的格式是 name&age&gender（比如，小王 &28& 男）。我们希望写一个程序，从 users.txt 文件中逐行读取用户信息，然后格式化成 name\tage\tgender（其中，\t 是分隔符）这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted_users.txt 中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。

C 语言：

```c
struct User {
  char name[64];
  int age;
  char gender[16];
};

struct User parse_to_user(char* text) {
  // 将text(“小王&28&男”)解析成结构体struct User
}

char* format_to_text(struct User user) {
  // 将结构体struct User格式化成文本（"小王\t28\t男"）
}

void sort_users_by_age(struct User users[]) {
  // 按照年龄从小到大排序users
}

void format_user_file(char* origin_file_path, char* new_file_path) {
  // open files...
  struct User users[1024]; // 假设最大1024个用户
  int count = 0;
  while(1) { // read until the file is empty
    struct User user = parse_to_user(line);
    users[count++] = user;
  }
  
  sort_users_by_age(users);
  
  for (int i = 0; i < count; ++i) {
    char* formatted_user_text = format_to_text(users[i]);
    // write to new file...
  }
  // close files...
}

int main(char** args, int argv) {
  format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");
}
```



java：

```java
 public class User {
  private String name;
  private int age;
  private String gender;
  
  public User(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  public static User praseFrom(String userInfoText) {
    // 将text(“小王&28&男”)解析成类User
  }
  
  public String formatToText() {
    // 将类User格式化成文本（"小王\t28\t男"）
  }
}

public class UserFileFormatter {
  public void format(String userFile, String formattedUserFile) {
    // Open files...
    List users = new ArrayList<>();
    while (1) { // read until file is empty 
      // read from file into userText...
      User user = User.parseFrom(userText);
      users.add(user);
    }
    // sort users by age...
    for (int i = 0; i < users.size(); ++i) {
      String formattedUserText = user.formatToText();
      // write to new file...
    }
    // close files...
  }
}

public class MainApplication {
  public static void main(String[] args) {
    UserFileFormatter userFileFormatter = new UserFileFormatter();
    userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
  }
}
```

对比上面的两种编码方式，我们可以很明显的看出来：

- 对于面对过程的编程风格，其代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的
- 对于面对对象的编程风格，其代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。



## 面向对象编程相比面向过程编程有哪些优势

### OOP 更加能够应对大规模复杂程序的开发

对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。

因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。

如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。

**面向对象编程是以类为思考对象。**

在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。

当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。

除此之外，**面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式**。

比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

对于面对过程来说，其实也可以将方法和数据结构放到不同的文件中去，但是这毕竟不是强制的，而且其付出的代价，肯定是没有面对对象低。

这里要明确一点：面对对象和面对过程不是对立的，很多时候，我们在写代码的时候，也会借鉴面向过程的优点



### OOP 风格的代码更易复用、易扩展、易维护

面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。

而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。

我们简单的回顾一下，面对对象的四大特性

首先，我们先来看下**封装特性**。

封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。

面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。

因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。

其次，我们再来看下**抽象特性**。

我们知道，函数本身就是一种抽象，它隐藏了具体的实现。

我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。

不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。

基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。

再次，我们来看下**继承特性**。

继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。

如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。

最后，我们来看下多态特性。

基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。

在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。

当然，我们不是说面向过程就不能做到这样，但是付出的代价可能要高一些



### OOP 语言更加人性化、更加高级、更加智能

跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。

前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。

我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。

而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。



### 总结

> 什么是面向过程编程？什么是面向过程编程语言？

实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。

理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。

相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。

相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。



> 面向对象编程相比面向过程编程有哪些优势？

- 对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
- 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
- 从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。





## 哪些代码设计看似是面向对象，实际是面向过程的？

在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。

我们通过下面几个例子来看看



> 滥用 getter、setter 方法

在开发的时候，我们很经常会看到，在定义完属性之后，就顺手把这些数据的get和set方法通过idea或者Lombok 插件自动生成

很多时候我们都会认为，迟早会用到，定义上去似乎也无伤大雅

但是实际上，它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我们一旦将所有的set方法都定义出来了，那所有的属性都可以随意的操作，那和面向对象有什么区别呢

我们来看一个例子

```java

public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
```

在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。

对于 itemsCount、totalPrice 两个属性，我们定义了它们的 getter、setter 方法。对于 items 属性，我们定义了它的 getter 方法和 addItem() 方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？

我们先来看前两个属性，itemsCount 和 totalPrice。虽然我们将它们定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。外部可以通过 setter 方法随意地修改这两个属性的值。

除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。

而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。

看完了前两个属性，我们再来看 items 这个属性。

对于 items 这个属性，我们定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上并不是。对于 itemsCount 和 totalPrice 这两个属性来说，定义一个 public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：

```java
ShoppingCart cart = new ShoppCart();
...
cart.getItems().clear(); // 清空购物车
```

看起来似乎没什么问题，但是这会导致itemsCount、totalPrice、items 三者数据不一致。

我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear() 方法的具体代码实现如下：

```java
public class ShoppingCart {
  // ...省略其他代码...
  public void clear() {
    items.clear();
    itemsCount = 0;
    totalPrice = 0.0;
  }
}
```

你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，ShoppingCart 类不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？

我们可以通过 Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。

```java
public class ShoppingCart {
  // ...省略其他代码...
  public List<ShoppingCartItem> getItems() {
    return Collections.unmodifiableList(this.items);
  }
}

public class UnmodifiableList<E> extends UnmodifiableCollection<E>
                          implements List<E> {
  public boolean add(E e) {
    throw new UnsupportedOperationException();
  }
  public void clear() {
    throw new UnsupportedOperationException();
  }
  // ...省略其他代码...
}

ShoppingCart cart = new ShoppingCart();
List<ShoppingCartItem> items = cart.getItems();
items.clear();//抛出UnsupportedOperationException异常
```

不过，这样的实现思路还是有点问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据。

```java
ShoppingCart cart = new ShoppingCart();
cart.add(new ShoppingCartItem(...));
List<ShoppingCartItem> items = cart.getItems();
ShoppingCartItem item = items.get(0);
item.setPrice(19.0); // 这里修改了item的价格属性
```

这个问题其实很多人都遇到过，就涉及到浅复制和深复制了，具体就不展开了

getter、setter 问题我们就讲完了，我稍微总结一下，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。

这个地方和我上次做的奖金池有点类似，但是我也是直接将所有的属性的set方法暴露出来，这确实会存在一些问题。



>滥用全局变量和全局方法

另外一个违反面向对象编程风格的例子，那就是滥用全局变量和全局方法。首先，我们先来看，什么是全局变量和全局方法？

对于面对过程的编程语言来说，全局变量和全局方法是十分常用的，但是对于面对对象的编程语言来说，还是比较少的

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。

单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。

静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。

静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。

在刚刚介绍的这些全局变量和全局方法中，Constants 类和 Utils 类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。

**我们先来看一下，在我过去参与的项目中，一种常见的 Constants 类的定义方法。**

```java
public class Constants {
  public static final String MYSQL_ADDR_KEY = "mysql_addr";
  public static final String MYSQL_DB_NAME_KEY = "db_name";
  public static final String MYSQL_USERNAME_KEY = "mysql_username";
  public static final String MYSQL_PASSWORD_KEY = "mysql_password";
  
  public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
  public static final int REDIS_DEFAULT_MAX_IDLE = 50;
  public static final int REDIS_DEFAULT_MIN_IDLE = 20;
  public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
  
  // ...省略更多的常量定义...
}
```

在这段代码中，我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。不过，定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点：

- 影响代码的可维护性

   如果参与开发的工程师有很多个，在开发的过程中，往往都要修改到这个类，那这个类就会愈发的庞大，会导致查找的困难以及冲突的几率增大

- 增加代码的编译时间

  当这个类定义了很多的变量的时候，依赖这个类的代码就会有很多。那每次修改这个类之后，都会导致需要用到它的其他类都要进行重编译，就会浪费大量的时间。

- 影响代码的复用性

  如果我们要在其他的类复用用到这个常量类的类时，我们不管怎么，都要把整个常量类都拷贝过去，也就会引入许多无关变量。

那怎么解决呢？

- 第一个是将这个庞大的常量类进行拆分，拆成多个具体到功能的常量类，RedisConstants，MySqlConstants...
- 第二个是不额外定义一个常量类，而是直接将常量定义到使用他的类中，这样可以提高内聚性和复用性。

对于开发来说，正常来讲，对于多个类都会用到的常量，我们会放到常量类中，并标明其作用

对于单个类自己用到的，我们都会直接写到对应的类中去，实现高内聚。



**讲完了 Constants 类，我们再来讨论一下 Utils 类。**

实际上，Utils 类的出现是基于这样一个问题背景：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。

可能有的人会想到可以利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。

但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。

既然继承不能解决这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。

除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。



> 定义数据和方法分离的类

最后一种十分常见，就是数据定义在一个类中，方法定义在另一个类中。

如果你是基于 MVC 三层结构做 Web 方面的后端开发，这样的代码你可能天天都在写。

传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。

不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。

- Controller 层负责暴露接口给前端调用
- Service 层负责核心业务逻辑
- Repository 层负责数据读写。

而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。

实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分 Web 项目都是基于这种开发模式来开发呢？

这就涉及到充血模型和贫血模型之前的区别，我们后面再详细的讲讲这个问题。

那么问题来了，**在面向对象编程中，为什么容易写出面向过程风格的代码？**

这是因为我们人的思维的问题，对于一件事情，我们正常来说，都是想着一步步解决，面向过程编程风格恰恰符合人的这种流程化思维方式。

而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。

这也就是说，为什么说面对对象只是适合处理复杂程序的开发，但不是特别符合人类的思维习惯

除此之外，向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。



但是这里并不是就说面向过程编程及面向过程编程语言就真的无用武之地

如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。

其实我们在开发到具体的方法的时候，用的还是面对过程的编程思想。面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。

除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。

记住一个点，我们的目标是写出易维护，易读，易复用，易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。



### 总结：

三种违反面向对象编程风格的典型代码设计

- 滥用 getter、setter 方法

  在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。

  除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。

- Constants 类、Utils 类的设计问题

  对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。

  除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。

- 基于贫血模型的开发模式

  关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。

  这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。







# 23种设计模式（GOF23）

## 1、是什么

- 设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。
- 他不是语法规则，而是一套用来提高代码可复用性，可维护性，可读性，稳健性以及安全性的解决方案
- 设计模式的本质是面向对象设计原理的实际应用，是对类的封装性，继承性和多态性以及类的关联关系和组合关系的充分理解

## 2、基本要素

- 模式名称
- 问题
- 解决方案
- 效果

## 3、有什么

- 创建型模式：帮助我们去创造对象，而不是使用 new 运算符直接实例化对象
  
  ​	这些设计模式提供了一种在**创建对象**的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
  
  - **单例模式**：唯一实例
  - **工厂模式**：简单工厂和工厂，简单工厂是一个工厂生产多个品牌的车，工厂是一个工厂生产一个品牌的车
  - **抽象工厂模式**：超级工厂，抽象出共同点，多维（华为和苹果都生产路由器和手机）
  - **建造者模式**：一砖一瓦的拼上去，步骤不变，但是顺序可以变，要有有个指挥者I（进阶：无指挥者，客户端自行搭配）
  - 原型模式：复制原来的类生成新的类
  
- 结构性模式
  
  ​	这些设计模式关注**类和对象的组合**。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
  
  - **适配器模式**（Adapter Pattern）：通过继承和组合实现原来的类，然后实现要配对的接口
  
  - **桥接模式**（Bridge Pattern）：有点像多继承，多维度。就像一座桥，可以把两个变化的维度连接起来!
  
  - 过滤器模式（Filter Criteria Pattern）：就是通过过滤器过滤出你想要的东西
  
  - 组合模式（Composite Pattern）：统一接口，然后树状排列生成有层次的数据
  
  - **代理模式**（Proxy Pattern）：静态和动态，静态相当于一个中介，动态依赖两个类，然后实现动态生成代理的类
  
  - **装饰器模式**（Decorator Pattern）：加强原来的类的功能，一个气球经过装饰变成了红色的气球
  
  - 外观模式（Facade Pattern）：统一一个接口进行调用，controller层
  
  - 享元模式（Flyweight Pattern）：没有再创建，有就直接用（String字符串在缓存池，连接池）
  
    
  
- 行为型模式
  
  ​	这些设计模式特：别关注对象之间的**通信**
  
  - **模版方法模式**：确定一个框架，然后子类实现具体的细节
  - 命令模式：将请求封装成命令
  - **迭代器模式**：容器的迭代器
  - **观察者模式**：发布-订阅模式，一个类发生了变化，依赖他的对象自动发生相应的变化
  - 中介者模式：由多对多变成了多对一
  - 备忘录模式：快照
  - 解释器模式：编译原理的文法，通过文法来实现组合
  - **状态模式**：定义不同的状态做不同的事情
  - **策略模式**：可以根据不同的环境选择不同的算法，上下文
  - **职责链模式**：链表，一层层进行比较，能处理就处理，不能处理继续往后传递
  - 访问者模式：通过不同的方法去观察同一个东西，就能获得不同的结构，构件一个元素接口和一个访问者接口
  
- **J2EE 模式**

  ​	这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

  - MVC 模式（MVC Pattern）
  - 业务代表模式（Business Delegate Pattern）
  - 组合实体模式（Composite Entity Pattern）
  - 数据访问对象模式（Data Access Object Pattern）
  - 前端控制器模式（Front Controller Pattern）
  - 拦截过滤器模式（Intercepting Filter Pattern）
  - 服务定位器模式（Service Locator Pattern）
  - 传输对象模式（Transfer Object Pattern）





# OOP七大原则

## 开闭原则：对扩展开放，对修改关闭

- 你扩展可以，但是不要改变之前的东西

## 里氏替换原则：继承必须确保超类所拥有的所有性质在子类中仍然成立

- 你要实现子类可以，但是你要保证能够拥有父类所有的性质
- 企鹅，鸵鸟就不符合

## 依赖倒置原则：要面向接口编程，不要面向实现编程

- 原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
- 依赖倒置原则是实现开闭原则重要途径之一。
- 就是面向接口

## 单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性

- 指类变化的原因，一个类应当有且只有一个引起它变化的原因，若有多个则该类需要拆分。
  
- 如果一个对象承担了太多职责，至少会存在以下两个缺点：
  
  - 当一个职责变化时，可能会削弱或抑制该类实现其他职责的能力。
  
  - 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。
  
- 单一职责同样也适用于方法。一个方法应该尽可能做好一件事情，如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。

- 高内聚，低耦合

## 接口隔离原则：要为各个类建立他们需要的专用接口

- 和上一个差不多，主要就是要求接口的粒度要小，一个接口做一件事
- 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
- 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；
- 接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

## 迪米特原则：只与你的直接朋友交谈，不跟“陌生人”说话

- 两个类的联系使用第三方，降低两个类的耦合

## 合成复用原则：尽量先试用组合或者聚合等关系关联关系来实现，其次才考虑使用继承关系来实现

- 类和类之间的关系尽量是“have a”关系（组合），而不是“is a”的关系（继承）



# 单例模式

## 1、是什么

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**应用实例：**

- 1、一个班级只有一个班主任。
- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

- 1、要求生产唯一序列号。
- 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
- Windows的任务管理器
- Windows的回收站
- 项目中，读取配置文件的类，一般也只有一个对象，没必要每次都去new对象读取
- 网站的计数器一般也会采用单例模式，可以保证同步
- 数据库连接池的设计一般也是单例模式
- 在Servlet编程中，每个Servlet也是单例的
- 在Spring中，每个Bean默认就是单例的

**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

核心作用：保证一个类只有一个实例，并且提供一个访问该类的实例的全局访问点

## 2、测试

```java
public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
    //这个是核心
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}

```

从 singleton 类获取唯一的对象。

```java
public class SingletonPatternDemo {
   public static void main(String[] args) {
 
      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();
 
      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();
 
      //显示消息
      object.showMessage();
   }
}
```

## 3、单例模式的几种实现方式

单例模式的实现有多种方式，如下所示：

### 1、饿汉式

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式比较常用，但容易产生垃圾对象。
优点：没有加锁，执行效率会提高。
缺点：类加载时就初始化，浪费内存。
它基于 classloader机制 （类加载机制：**JVM在类加载的过程，保证了不会初始化多个 static 对象**）避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

```java
public class Hungry {
    private static Hungry instance = new Hungry();
    private Hungry (){}
    public static Hungry getInstance() {
        return instance;
    }
}
```

由于饿汉式存在资源浪费，所以就出现了懒汉式

### 2、懒汉式，线程不安全

**是否 Lazy 初始化：**是

**是否多线程安全：**否

**实现难度：**易

**描述：**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java
public class LazyMan {
    private static LazyMan instance;
    private LazyMan (){
        System.out.println(Thread.currentThread().getName()+"OK");
    }

    public static LazyMan getInstance() {
        if (instance == null) {
            instance = new LazyMan();
        }
        return instance;
    }
    //跑的时候，我们会发现，他有时候不止创建了一个线程
    public static void main(String[] args){
        for(int i=0;i<10;i++){
            new Thread(()->{
                LazyMan.getInstance();
            }).start();
        }
    }
}
```

### 3、双检锁/双重校验锁（DCL，即 double-checked locking）

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**较复杂

**描述：**这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。

```java
public class DCLLazyMan {
    //DCL + 原子性操作
    private volatile static DCLLazyMan dclLazyMan;		//DCL懒汉式还是不安全，因为创建对象不是原子操作
    private DCLLazyMan (){}
    public static DCLLazyMan getInstance() {
        if (dclLazyMan == null) {
            synchronized (DCLLazyMan.class) {		//第一层
                if (dclLazyMan == null) {			//第二层
                    dclLazyMan = new DCLLazyMan();  //不是原子性操作
                    /*
                     * 正常我们创建新的对象有三个步骤：
                     * 	1、分配内存空间
                     * 	2、执行构造方法，初始化对象
                     * 	3、把对象指向空间
                     * 但是我们知道，有时候并不是按顺序执行的，
                     * 这样就可能存在线程A在创造，这时候线程B把线程A的空间占了，这时候创造出来的线程就是空的
                     * 这也就是为什么我们要使用volatile的原因了
                     */
                }
            }
        }
        return dclLazyMan;
    }
}
```

到了这里之后，可能还有有人提出静态内部类

![image-20210626114159449](D:\idea\23种设计模式.assets\image-20210626114159449.png)

其实牛逼的人，会发现，其实都是不安全的，为什么呢？因为我们Java有一种很霸道的东西------>反射	

我们实验一下

```java
    public static void main(String[] args) throws Exception {
        DCLLazyMan instance = DCLLazyMan.getInstance();
        Constructor<DCLLazyMan> constructor = DCLLazyMan.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        DCLLazyMan instance2 = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

运行一下，我们可以很明显的看到，两个对象的Hash值不同

这个其实很好解决，只要在我们的构造方法中加个锁就行

```java
private DCLLazyMan (){
        synchronized (DCLLazyMan.class){
            if(dclLazyMan!=null){
                throw new RuntimeException("不要试图通过反射破坏异常");
            }
        }
    }
```

是不是觉得没问题了呢，不你错了，还是能够破坏

只要我们不要通过getInstance()去创建对象

```java
    public static void main(String[] args) throws Exception {
//        DCLLazyMan instance = DCLLazyMan.getInstance();
        Constructor<DCLLazyMan> constructor = DCLLazyMan.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        DCLLazyMan instance2 = constructor.newInstance();
        DCLLazyMan instance = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

又运行成功了。还有人说，那我加一个标志位，进去的时候看有没有跑过构造器，有就抛出异常呗

```java
private static boolean flag = false;
    private DCLLazyMan (){
        synchronized (DCLLazyMan.class){
            if(!flag){
                flag = true;
            }else{
                throw new RuntimeException("不要试图通过反射破坏异常");
            }
        }
    }
```

运行了一下，发现可以，但是我们知道，反射可以拿到你的构造器，那你的变量不是轻而易举就可以拿到

```java
public static void main(String[] args) throws Exception {
//        DCLLazyMan instance = DCLLazyMan.getInstance();
        Constructor<DCLLazyMan> constructor = DCLLazyMan.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        Field flag = DCLLazyMan.class.getDeclaredField("flag");
        DCLLazyMan instance2 = constructor.newInstance();
        flag.set(instance2,false);
        DCLLazyMan instance = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

好了，差不多了，再试下去就破防了

那我们怎么办呢

打开newInstance（）方法，我们可以看到枚举自带单例

![image-20210324115417821](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324115417821.png)

### 4、登记式/静态内部类

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**一般

**描述：**这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域**使用延迟初始化**，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。

```java
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```



### 5、枚举

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易 它更简洁，自动支持序列化机制，绝对防止多次实例化。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线 程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。1 
不能通过 reflection attack 来调用私有构造方法。

```java
public enum  EnumSingle {
    INSTANCE;

    public EnumSingle getInstance(){
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws NoSuchMethodException {
        EnumSingle instance = EnumSingle.INSTANCE;
        
    }
}
```

走到这里我们肯定要试试啦，但是我们发现，我们不知道他调用的构造器是什么，那么我们看看输入的.class文件

![image-20210324120719209](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324120719209.png)

看到了他是执行空参的构造方法

那我们就按照空参的来

```java
public static void main(String[] args) throws Exception {
        EnumSingle instance = EnumSingle.INSTANCE;
        Constructor<EnumSingle> constructor = EnumSingle.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        EnumSingle instance2 = constructor.newInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
```

一运行，发现不对

![image-20210324120930579](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324120930579.png)

这和我们想的有很大的出入，那也就是说，这里用的不是空参的构造方法

idea骗了我们，那我们试试用cmd能不能得到我们想要的

![image-20210324121232339](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324121232339.png)

然后发现，不能

接下来清楚我们的工具jap

![image-20210324130021722](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130021722.png)

![image-20210324130045929](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130045929.png)

然后我们会发现文件里多了一个东西，打开

![image-20210324130131373](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130131373.png)

终于由我们想要的了，再试试

![image-20210324130249435](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210324130249435.png)

终于对了



总结一下：

​	 只创建一个对象，同时构造器私有，破坏了七大原则的单一职责



# 工厂模式

## 1、是什么

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

核心本质：

实例化对象不使用new，用工厂方法代替

将选择实现类，创建对象统一管理和控制。从而将**调用者跟我们的实现类解耦**。	



## 2、简单工程模式（静态工厂）

用来生产同一等级结构中的任意产品(对于增加新的产品，需要扩展已有代码

![image-20210329171850817](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329171850817.png)

```java
public interface Car {
    public void name();
}
```

```java
public class TSLA implements Car{
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
```

```java
public class WuLing implements Car{
    @Override
    public void name() {
        System.out.println("五菱");
    }
}	
```

```java
public class CarFactory {

    //方法一
    public Car getCar(String car){
        if(car.equals("五菱")){
            return new WuLing();
        }else if(car.equals("特斯拉")){
            return new TSLA();
        }
        return null;
    }

    //方法二
    public Car getWuLing(){
        return new WuLing();
    }

    public Car getTSLA(){
        return new TSLA();
    }
}
```

这时候如果大众进来了，我们又要对这个工厂进行修改，违背OOP七大原则的第一条：开闭原则



## 3、工厂模式

用来生产同一等级结构中的固定产品(支持增加任意产品)   满足了开闭原则

![image-20210329172208226](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329172208226.png)

```java
public interface Car {
    public void name();
}
```

```java
public class TSLA implements Car {
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
```

```java
public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println("五菱");
    }
}
```

```java
public interface CarFactory {
    public Car getCar();
}
```

```java
public class TesLaFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new TSLA();
    }
}
```

```java
public class WuLingFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new WuLing();
    }
}
```

我们可以很明显的看出，虽然满足了OOP，但是代码量多了很多

所以我们一般是使用静态工厂



## 4、总结

结构复杂度： simple

代码复杂度：simple

编程复杂度：simple

管理上的复杂度： simple



根据设计原则：工厂方法模式

根据实际业务：简单工厂模式



# 抽象工厂

## 1、是什么

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**关键代码：**在一个工厂里聚合多个同类产品。



## 2、举例

![image-20210329172907172](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329172907172.png)

1、产品

```java
public interface IPhoneProduct {
    public void start();

    public void close();

    public void sendMgs();

    public void call();
}
```

```java
public interface IRouterProduct {
    public void start();

    public void close();

    public void openWifi();

    public void setting();
}
```



2、产品族

- 小米

  ```java
  public class XiaomiPhone implements IPhoneProduct{
      @Override
      public void start() {
          System.out.println("小米手机开机了");
      }
  
      @Override
      public void close() {
          System.out.println("小米手机关机了");
      }
  
      @Override
      public void sendMgs() {
          System.out.println("小米手机发信息");
      }
  
      @Override
      public void call() {
          System.out.println("小米手机打电话");
      }
  }
  ```

  

  ```java
  public class XiaomiRouter implements IRouterProduct {
      @Override
      public void start() {
          System.out.println("小米路由器开机了");
      }
  
      @Override
      public void close() {
          System.out.println("小米路由器关机了");
      }
  
      @Override
      public void openWifi() {
          System.out.println("小米路由器打开Wifi");
      }
  
      @Override
      public void setting() {
          System.out.println("小米路由器设置");
      }
  }
  ```

  

- 华为

  ```java
  public class HuaweiPhone implements IPhoneProduct {
      @Override
      public void start() {
          System.out.println("华为手机开机了");
      }
  
      @Override
      public void close() {
          System.out.println("华为手机关机了");
      }
  
      @Override
      public void sendMgs() {
          System.out.println("华为手机发信息");
      }
  
      @Override
      public void call() {
          System.out.println("华为手机打电话");
      }
  }
  ```

  

  ```java
  public class HuaweiRouter implements IRouterProduct {
      @Override
      public void start() {
          System.out.println("华为路由器开机了");
      }
  
      @Override
      public void close() {
          System.out.println("华为路由器关机了");
      }
  
      @Override
      public void openWifi() {
          System.out.println("华为路由器打开Wifi");
      }
  
      @Override
      public void setting() {
          System.out.println("华为路由器设置");
      }
  }
  ```

  

接下来造工厂

```java
public interface ProductFactory {
    public IPhoneProduct getPhone();

    public IRouterProduct getRouter();
}
```

```java
public class XiaomiFactory implements ProductFactory {
    @Override
    public IPhoneProduct getPhone() {
        return new XiaomiPhone();
    }

    @Override
    public IRouterProduct getRouter() {
        return new XiaomiRouter();
    }
}
```

```java
public class HuaweiFactory implements ProductFactory{
    @Override
    public IPhoneProduct getPhone() {
        return new HuaweiPhone();
    }

    @Override
    public IRouterProduct getRouter() {
        return new HuaweiRouter();
    }
}
```

![image-20210329173450203](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210329173450203.png)

说白了，就是我们同一个工厂的抽象，在一个更高的纬度去看待问题

但是这里同样破坏了OOP的第一条规则

适用场景:

* 客户端（应用层)不依赖于产品类实例如何被创建、实现等细节
* 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码
* 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现

优点:

* 具体产品在应用层的代码隔离，无需关心创建的细节
* 将一个系列的产品统一到一起创建

缺点:

* 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;
* 增加了系统的抽象性和理解难度



# 建造者模式

## 1、是什么

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**关键代码：**建造者：创建和提供实例，指挥者：管理建造出来的实例的依赖关系。

## 2、测试

就拿房子来举例：大多数房子，都是那几个建造步骤，但有时候顺序可以换一下，这时候就可以使用建造者模式了

![image-20210330095448797](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330095448797.png)

假设造房简化为如下步骤:(1）地基(2）钢筋工程(3）铺电线(4）粉刷；“如果”要盖一座房子，首先要找一个建筑公司或工程承包商(指挥者)。承包商指挥工人(具体建造者）过来造房子(产品)，最后验收。

```java
//产品
public class Product {
    private  String buildA;
    private  String buildB;
    private  String buildC;
    private  String buildD;
    ....(set方法，toString)
}
```

```java
//抽象的建造者
public abstract class Builder {
    abstract void buildA(); //地基
    abstract void buildB(); //钢筋工程
    abstract void buildC(); //铺电线
    abstract void buildD(); //粉刷

    abstract Product getProduct();  //得到东西

}
```

```java
public class Worker extends Builder{

    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    void buildA() {
        product.setBuildA("地基");
        System.out.println("地基");
    }

    @Override
    void buildB() {
        product.setBuildB("钢筋工程");
        System.out.println("钢筋工程");
    }

    @Override
    void buildC() {
        product.setBuildC("铺电线");
        System.out.println("铺电线");
    }

    @Override
    void buildD() {
        product.setBuildD("粉刷");
        System.out.println("粉刷");
    }

    @Override
    Product getProduct() {
        return product;
    }

```

```java
//指挥：核心。
//负责指挥构建一个工程，工程如何建造，由他决定
public class Director {

    //指挥工人按顺序建造房子
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();

        return builder.getProduct();
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Director director = new Director();				//指挥者
        Product product = director.build(new Worker());	//由指挥者指导工人建房子，然后返回房子
        System.out.println(product);
    }
}
```

上面示例是Builder模式的常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。

通过静态内部类方式实现零件无序装配构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品

## 3、实现无指挥者

比如：麦当劳的套餐，服务员〈（具体建造者）可以随意搭配任意几种产品（零件）组成一款套餐（产品)，然后出售给客户。比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。

```java
public abstract class Build {
    abstract Build  putFood(String food);
    abstract Build  putWater(String water);
    abstract Product getProduct();

}
```

```java
//产品
public class Product {
    private String food = "汉堡";
    private String water = "可乐";
    //set()方法和toString()方法
}
```

````java
public class Worker extends Build {

    private Product product;

    public Worker() {
        product = new Product();
    }


    @Override
    Build putFood(String food) {
        product.setFood(food);
        return this;
    }

    @Override
    Build putWater(String water) {
        product.setWater(water);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}
````

```java
public class Consumer {
    public static void main(String[] args) {
        Worker worker = new Worker();
        Product product = worker.putWater("雪碧")
                .putFood("炸鸡")
                .getProduct();

        System.out.println(product);

    }
}
```

因为这里要使用链式编程，所以设定了返回值



## 4、总结

**优点:**
产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。

将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰

具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则“。

**缺点:**

建造者模式所创建的产品一般具有较多的共同点，其组成部分相似;如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。



# 原型模式

## 1、是什么

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**关键代码：** 实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()



## 2、例子

```java
public class Video implements Cloneable {                                    
    private String name;                                                     
    private Date creatTime;                                                  
                                                                             
    @Override                                                                
    protected Object clone() throws CloneNotSupportedException {             
        return super.clone();                                                
    }            
    
    //构造函数，get,set,toString方法
}
```

```java
public class BiliBili {
    public static void main(String[] args) throws CloneNotSupportedException {

        Video v1 = new Video("pwx", new Date());

        System.out.println(v1);
        System.out.println(v1.hashCode());

        Object v2 = v1.clone();
        System.out.println(v2);
        System.out.println(v2.hashCode());
    }
}
```

运行结果

![image-20210330160302610](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330160302610.png)

我们可以看到，这里是两个对象

但是这时候如果我们改了时间

```java
public class BiliBili {
    public static void main(String[] args) throws CloneNotSupportedException {

        Date date = new Date();
        Video v1 = new Video("pwx", date);

        System.out.println(v1);
        System.out.println(v1.hashCode());

        Object v2 = v1.clone();
        System.out.println(v2);
        System.out.println(v2.hashCode());

        date.setTime(1564351845);
        System.out.println(v1);
        System.out.println(v2);
    }
}
```

运行结果：

![image-20210330161818091](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330161818091.png)

我们会发现，这里两个对象的时间都改了，这和我们想要的不一样，这就是浅克隆

![image-20210330161006175](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330161006175.png)

浅克隆就是我们在克隆的时候，我们看到在克隆对象的时候，两个指向的是同一个对象

那试试深克隆

```java
public class Video implements Cloneable {                                    
    private String name;                                                     
    private Date creatTime;                                                  
                                                                             
    @Override                                                   
	protected Object clone() throws CloneNotSupportedException {
    	Object o = super.clone();                               
                                                            
    	//实现深克隆                                                 
    	Video v = (Video) o;                                    
    	//将这个对象的属性也进行克隆~                                        
    	v.creatTime = (Date) this.creatTime.clone();            
                                                            
    	return o;                                               
	}                                                                    
    
    //构造函数，get,set,toString方法
}
```

运行结果

![image-20210330161838768](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330161838768.png)

可以看到，我们在克隆的时候，把对象一起克隆了一个。



## 3、总结

**优点：** 

- 性能提高。 
- 逃避构造函数的约束。

**缺点：** 

- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
- 必须实现 Cloneable 接口。



# 适配器模式

## 1、是什么

<img src="C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330200814236.png" alt="image-20210330200814236" style="zoom:80%;" />

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，适配器是作为网线和笔记本之间的适配器。将网线插入适配器，再将适配器插入笔记本，这样就可以通过笔记本来上网了。



**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 

- 系统需要使用现有的类，而此类的接口不符合系统的需要。
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 
- 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或组合（推荐）。

**关键代码：**适配器继承或组合已有的对象，实现想要的目标接口。



## 2、举例

![image-20210330200649945](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210330200649945.png)

拿到首先我们会先创建三个类：电脑，网线，适配器（接口）

之后我们实现适配器实例，同时利用继承，适配网线的方法

之后我们再把适配器放入到电脑中去，这样电脑就是通过适配器调用网线的方法了

思路要清晰

```java
//要被适配的类：网线
public class Adaptee {

    public void request(){
        System.out.println("连接网线上网");
    }
}
```

```java
//接口转换器的抽象实现
public interface NetToUsb {

    //作用，处理请求，网线=>usb
    public void handleRequest();
}
```

```java
//真正的适配器~，需要连接USB，连接网线
//1、继承（类适配器，单继承）
public class Adapter extends Adaptee implements NetToUsb {
    @Override
    public void handleRequest() {
        super.request();    //可以上网了
    }
}
```

```java
//客户端类：想上网，插不上网线
public class Computer {

    public void net(NetToUsb adapter){
        //上网的具体实现，找一个转接头
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑，适配器，网线
        Computer computer = new Computer(); //电脑
        Adaptee adaptee = new Adaptee();    //网线
        Adapter adapter = new Adapter();    //适配器

        computer.net(adapter);
    }
}
```

这是第一种：继承

但是我们知道继承的局限性很大，一般来说我们会使用组合

```java
//真正的适配器~，需要连接USB，连接网线
//2、组合（对象适配器：常用）
public class Adapter2 implements NetToUsb {

    private Adaptee adaptee;		//

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void handleRequest() {
        adaptee.request();    //可以上网了
    }
}
```

```java
//客户端类：想上网，插不上网线
public class Computer {

    public void net(NetToUsb adapter){
        //上网的具体实现，找一个转接头
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑，适配器，网线
        Computer computer = new Computer();//电脑
        Adaptee adaptee = new Adaptee();    //网线
        Adapter2 adapter2 = new Adapter2(adaptee);    //适配器

        computer.net(adapter2);
    }
}
```

这就大大降低了耦合性



## 3、总结

> 优点

- 一个适配器可以把多个不同的适配器适配到同一个目标
- 可以适配一个是适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏替换原则”，适配者的子类也可以通过该适配器进行适配

> 缺点

- 对于Java等单继承语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。这也是我们为什么提倡用组合而不用继承的原因



# 桥接模式

## 1、是什么

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

![image-20210307205047982](file://C:\Users\86796\Desktop\java资料\设计模式\设计模式.assets\image-20210307205047982.png?lastModify=1617108118)

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**关键代码：**抽象类依赖实现类。

![image-20210307205302746](file://C:\Users\86796\Desktop\java资料\设计模式\设计模式.assets\image-20210307205302746.png?lastModify=1617108157)

这样就可以实现解耦了



## 2、举例

![image-20210307223607516](file://C:\Users\86796\Desktop\java资料\设计模式\设计模式.assets\image-20210307223607516.png?lastModify=1617108641)

```java
//牌子
public interface Brand {
    void info();
}
```

```java
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.println("苹果");
    }
}
```

```java
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.println("联想");
    }
}
```

```java
public abstract class Computer {
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info(){
        brand.info();
    }
}

// 台式机
class DeskTop extends Computer{
    public DeskTop(Brand brand) {
        super(brand);
    }

    public void info(){
        super.info();
        System.out.println("台式机");
    }
}

//笔记本
class LapTop extends Computer{
    public LapTop(Brand brand) {
        super(brand);
    }

    public void info(){
        super.info();
        System.out.println("笔记本");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Computer lapTop = new LapTop(new Apple());
        lapTop.info();

        Computer deskTop = new DeskTop(new Lenovo());
        deskTop.info();
    }
}
```

其实我们发现了桥接模式和适配器模式有一个共同点，都是通过组合把这两个不相关的类联系起来的



## 3、总结

**好处分析:**

桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多、桥接模式是比多继承方案更好的解决方法。极大的减少了子类的个数，从而降低管理和维护的成本

桥接模式提高了系统的可扩充性(在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符令开闭原则，**就像一座桥，可以把两个变化的维度连接起来!**

**劣势分析:**

桥接模式的引人会增加系统的理解与设计难度由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。







# 过滤器模式

## 1、是什么

过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

![image-20210331100203809](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210331100203809.png)

这个模式比较好理解



## 2、举例



![image-20210331095713296](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210331095713296.png)

定义一个具体要过滤的对象

```java
public class Person {
    private String name;            //名字
    private String gender;          //性别
    private String maritalStatus;   //婚宴状况

	//构造函数，get方法，toString方法
}
```

过滤接口

```java
//过滤的标准
public interface Criteria {

    List<Person> meetCriteria(List<Person> persons);
}
```

过滤器实例

```java
//过滤出来单身的
public class CriteriaSingle implements Criteria {
    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> singlePersons = new ArrayList<Person>();
        for (Person person : persons) {
            if(person.getMaritalStatus().equalsIgnoreCase("SINGLE")){
                singlePersons.add(person);
            }
        }
        return singlePersons;
    }
}
```

```java
//过滤出来是男的
public class CriteriaMale implements Criteria {
    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> malePersons = new ArrayList<Person>();
        for (Person person : persons) {
            //忽略大小写
            if(person.getGender().equalsIgnoreCase("MALE")){
                malePersons.add(person);
            }
        }
        return malePersons;
    }
}
```

```java
public class CriteriaFemale implements Criteria {
    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> malePersons = new ArrayList<Person>();
        for (Person person : persons) {
            //忽略大小写
            if(person.getGender().equalsIgnoreCase("FEMALE")){
                malePersons.add(person);
            }
        }
        return malePersons;
    }
}
```

交集和并集

```java
//并集
public class AndCriteria implements Criteria {

    private Criteria criteria;
    private Criteria otherCriteria;

    public AndCriteria(Criteria criteria, Criteria otherCriteria) {
        this.criteria = criteria;
        this.otherCriteria = otherCriteria;
    }

    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);
        return otherCriteria.meetCriteria(firstCriteriaPersons);
    }
}
```

```java
//交集
public class OrCriteria implements Criteria{

    private Criteria criteria;
    private Criteria otherCriteria;

    public OrCriteria(Criteria criteria, Criteria otherCriteria) {
        this.criteria = criteria;
        this.otherCriteria = otherCriteria;
    }

    @Override
    public List<Person> meetCriteria(List<Person> persons) {
        List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);
        List<Person> otherCriteriaPersons = otherCriteria.meetCriteria(persons);

        for (Person person : firstCriteriaPersons) {
            if(!otherCriteriaPersons.contains(person)){
                otherCriteriaPersons.add(person);
            }
        }
        return otherCriteriaPersons;
    }
}
```

MyTest

```java
public class MyTest {
    public static void main(String[] args) {
        List<Person> persons = new ArrayList<Person>();

        persons.add(new Person("Pwx","Male", "Single"));
        persons.add(new Person("Robert","Male", "Single"));
        persons.add(new Person("John","Male", "Married"));
        persons.add(new Person("Laura","Female", "Married"));
        persons.add(new Person("Diana","Female", "Single"));
        persons.add(new Person("Mike","Male", "Single"));
        persons.add(new Person("Bobby","Male", "Single"));

        Criteria male = new CriteriaMale();
        Criteria female = new CriteriaFemale();
        Criteria single = new CriteriaSingle();
        Criteria singleMale = new AndCriteria(single, male);
        Criteria singleFemale = new OrCriteria(single, female);

        System.out.println("Males: ");
        List<Person> malesPeople = male.meetCriteria(persons);
        for (Person person : malesPeople) {
            System.out.println(person);
        }

        System.out.println("Female: ");
        List<Person> femalesPeople = female.meetCriteria(persons);
        for (Person person : femalesPeople) {
            System.out.println(person);
        }

        System.out.println("SingleMale: ");
        List<Person> singleMalePeople = singleMale.meetCriteria(persons);
        for (Person person : singleMalePeople) {
            System.out.println(person);
        }

        System.out.println("singleFemale: ");
        List<Person> singleFemalePeople = singleFemale.meetCriteria(persons);
        for (Person person : singleFemalePeople) {
            System.out.println(person);
        }
    }
}
```





# 组合模式

## 1、是什么

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 

- 您想表示对象的部分-整体层次结构（树形结构）。 
- 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。

**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

2、举例

![image-20210331103958230](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210331103958230.png)

回去看看定义，所有的人都是员工，然后再对员工进行组合成树状，形成一个有层次的对象组

```java
public class Employee {
    private String name;                    //名字
    private String dept;                    //住址
    private int salary;                     //工资
    private List<Employee> subordinates;    //下属

    public Employee(String name, String dept, int salary) {
        this.name = name;
        this.dept = dept;
        this.salary = salary;
        subordinates = new ArrayList<>();
    }

    //添加一个下属
    public void add(Employee e) {
        subordinates.add(e);
    }

    //移除一个下属
    public void remove(Employee e) {
        subordinates.remove(e);
    }

    //获取所有下属
    public List<Employee> getSubordinates(){
        return subordinates;
    }

    public String toString(){
        return ("Employee :[ Name : "+ name
                +", dept : "+ dept + ", salary :"
                + salary+" ]");
    }
}
```

```java
public class CompositeTest {
    public static void main(String[] args) {
        Employee CEO = new Employee("John","CEO", 30000);

        Employee headSales = new Employee("Robert","Head Sales", 20000);

        Employee headMarketing = new Employee("Michel","Head Marketing", 20000);

        Employee clerk1 = new Employee("Laura","Marketing", 10000);
        Employee clerk2 = new Employee("Bob","Marketing", 10000);

        Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
        Employee salesExecutive2 = new Employee("Rob","Sales", 10000);

        CEO.add(headSales);
        CEO.add(headMarketing);

        headSales.add(salesExecutive1);
        headSales.add(salesExecutive2);

        headMarketing.add(clerk1);
        headMarketing.add(clerk2);

        //打印该组织的所有员工
        System.out.println(CEO);
        for (Employee headEmployee : CEO.getSubordinates()) {
            System.out.println(headEmployee);
            for (Employee employee : headEmployee.getSubordinates()) {
                System.out.println(employee);
            }
        }
    }
}
```

这样下来，我们会发现，整个类非常的有层次感



## 3、总结

优点：

- 高层模块调用简单。 
- 节点自由增加。

缺点：

- 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

# 代理模式

Spring AOP



# 装饰器模式

## 1、是什么

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**关键代码：** 1、Component 类充当**抽象**角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。



## 2、举例

![image-20210401165317839](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210401165317839.png)



Shape接口

```java
//定义一个图形
public interface Shape {
    public void draw();
}
```

```java
//定义一个圆
public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Shape--> Circle");
    }
}
```

```java
//定义一个矩形
public class Rectangle implements Shape{

    @Override
    public void draw() {
        System.out.println("Shape-->Rectangle");
    }
}
```



抽象修饰类

```java
public abstract class ShapeDecorator implements Shape {

    protected Shape shape;

    public ShapeDecorator(Shape shape) {
        this.shape = shape;
    }

    @Override
    public void draw() {
        shape.draw();
    }
}
```

```java
//创建扩展了 ShapeDecorator 类的实体装饰类。
public class RedShapeDecorator extends ShapeDecorator {
    public RedShapeDecorator(Shape shape) {
        super(shape);
    }

    @Override
    public void draw() {
        shape.draw();
        setRedBorder(shape);
    }

    private void setRedBorder(Shape shape){
        System.out.println("Border Color: Red");
    }
}
```

Test

```java
public class MyTest {
    public static void main(String[] args) {
        Shape circle = new Circle();
        ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
        ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
        //Shape redCircle = new RedShapeDecorator(new Circle());
        //Shape redRectangle = new RedShapeDecorator(new Rectangle());
        System.out.println("Circle with normal border");
        circle.draw();

        System.out.println("\nCircle of red border");
        redCircle.draw();

        System.out.println("\nRectangle of red border");
        redRectangle.draw();
    }
}
```



## 3、总结

**优点：**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**缺点：**多层装饰比较复杂。



对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。

对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。

他们之间的边界确实比较模糊，两者都是对类的方法进行扩展，具体区别如下：

1、装饰器模式强调的是**增强自身**，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让**别人**帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。

2、装饰模式是以对客户端透明的方式扩展对象的功能，是**继承**方案的一个替代方案；代理模式则是给一个对象**提供一个代理对象**，并由代理对象来控制对原有对象的引用；

3、装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；



# 外观模式

## 1、是什么

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性，说白了，就是加一层

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

**意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**主要解决：**降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。

**何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。

**如何解决：**客户端不与系统耦合，外观类与系统耦合。

**关键代码：**在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

**应用实例：** JAVA 的三层开发模式。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3BwZHh6ei9pbWFnZXMvbWFzdGVyL2ltZy9QaWNHby1HaXRodWItUGljQmVkLzIwMjAwNDI4MTMzNjQ5LnBuZw?x-oss-process=image/format,png)

## 2、举例

![image-20210401180809061](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210401180809061.png)

Shape还是和装饰器模式一样

然后定义一个ShapeMaker，统一管理Shape

```java
public class ShapeMaker {
    private Shape circle;
    private Shape rectangle;
    private Shape square;

    public ShapeMaker() {
        circle = new Circle();
        rectangle = new Rectangle();
        square = new Square();
    }

    public void drawCircle(){
        circle.draw();
    }
    public void drawRectangle(){
        rectangle.draw();
    }
    public void drawSquare(){
        square.draw();
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        ShapeMaker shapeMaker = new ShapeMaker();

        shapeMaker.drawCircle();
        shapeMaker.drawRectangle();
        shapeMaker.drawSquare();
    }
}
```



## 3、总结

优点：

降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类，满足“迪米特法则”

对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。

降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

缺点：

增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。




# 享元模式

## 1、是什么

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试**重用**现有的同类对象，如果未找到匹配的对象，则创建新对象。



**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**在有大量对象时，有可能会造成内存溢出（OOM），我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

**关键代码：**用 HashMap 存储这些对象。

**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。



## 2、举例

![image-20210401191927518](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210401191927518.png)

颜色是共同的，而且是有限的，所以把他抽出来，所谓分组的条件

```java
public interface Shape {
    void draw();
}
```

```java
public class Circle implements Shape {
    private String color;
    private int x;
    private int y;
    private int radius;

    public Circle(String color){
        this.color = color;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Circle: Draw() [Color : " + color
                +", x : " + x +", y :" + y +", radius :" + radius);
    }
}
```

核心：HashMap存储对象

```java
public class ShapeFactory {
    private static final HashMap<String, Shape> circleMap = new HashMap<>();

    public static Shape getCircle(String color) {
        Circle circle = (Circle)circleMap.get(color);

        if(circle == null) {
            circle = new Circle(color);
            circleMap.put(color, circle);
            System.out.println("Creating circle of color : " + color);
        }
        return circle;
    }

    public static int size(){
        return circleMap.size();
    }
}
```

测试

```java
public class MyTest {
    private static final String[] colors =
            { "Red", "Green", "Blue", "White", "Black" };
    public static void main(String[] args) {

        for(int i=0; i < 20; ++i) {
            Circle circle =
                    (Circle)ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
        System.out.println(ShapeFactory.size());
    }
    private static String getRandomColor() {
        return colors[(int)(Math.random()*colors.length)];
    }
    private static int getRandomX() {
        return (int)(Math.random()*100 );
    }
    private static int getRandomY() {
        return (int)(Math.random()*100);
    }
}
```

分组，共享对象



## 3、总结

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。







# 命令模式

## 1、是什么

命令模式是一种数据驱动的设计模式，它属于行为型模式。

请求以命令的形式包裹在对象中，并传给调用对象

调用对象寻找可以处理该命令的合适对象，并把该命令传给相应的对象，该对象执行命令



**意图：**将一个请求封装成一个对象，从而是你可以用不同的请求对客户进行形参化。对**行为请求和行为实现实现了解耦**





## 2、举例

![image-20210402104728597](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210402104728597.png)

定义一个命令

```java
//命令
public interface Order {
    public void execute();
}
```

定义请求

```java
//请求
public class Stock {
    private String name = "ABC";
    private int quantity = 10;


    public void buy(){
        System.out.println("Stock----->buy");
        System.out.println("Name:"+name+","+"quantity:"+quantity);
    }

    public void sell(){
        System.out.println("Stock----->sell");
        System.out.println("Name:"+name+","+"quantity:"+quantity);
    }
}
```

对请求实现封装

```java
//买的命令
public class BuyStock implements Order {
    private Stock stock;

    public BuyStock(Stock stock) {
        this.stock = stock;
    }

    @Override
    public void execute() {
        stock.buy();
    }
}
```

```java
//卖的命令
public class SellStock implements Order {
    private Stock stock;

    public SellStock(Stock stock) {
        this.stock = stock;
    }

    @Override
    public void execute() {
        stock.sell();
    }
}
```

这就完成了对请求的封装

然后是调用

```java
public class Broket {
    private List<Order> orders = new ArrayList<>();

    public void takeOrder(Order order){
        orders.add(order);
    }

    public void placeOrders(){
        for (Order order : orders) {
            order.execute();
        }

        orders.clear();
    }
}
```

这里我们把请求所封装成的对象`order`传给调用者，调用者再通过具体的命令去实现具体的请求

```java
public class MyTest {
    public static void main(String[] args) {
        Stock stock = new Stock();
        BuyStock buyStock = new BuyStock(stock);
        SellStock sellStock = new SellStock(stock);

        Broket broket = new Broket();
        broket.takeOrder(buyStock);
        broket.takeOrder(sellStock);

        broket.placeOrders();
    }
}
```



## 3、总结

优点：

- 降低了系统的耦合
- 新的请求很容易添加到系统中去

缺点：

- 当请求过多的时候，可能会产生大量的具体命令



# 责任链模式

## 1、是什么

顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，**对请求的发送者和接收者进行解耦**。这种类型的设计模式属于行为型模式。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

**何时使用：**在处理消息的时候以过滤很多道。

**如何解决：**拦截的类都实现**统一接口**。

**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。



## 2、举例

![image-20210408145358184](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210408145358184.png)

这个模式的首要思想是创造一条处理链。创造之前先写一个统一接口

```java
//抽象的记录类
public abstract class AbstractLogger {
    public static int INFO = 1;
    public static int DEBUG = 2;
    public static int ERROR = 3;
    
    protected int level;
    
    //责任链的下一个元素
    protected AbstractLogger nextLogger;

    public void setNextLogger(AbstractLogger nextLogger) {
        this.nextLogger = nextLogger;
    }
    
    abstract protected void write(String message);
        
    public void logMessage(int level,String message){
        if(this.level<=level){
            write(message);
        }
        
        if(nextLogger != null){
            nextLogger.logMessage(level,message);
        }
    }
}
```

然后实现接口

```java
public class ErrorLogger extends AbstractLogger {
    public ErrorLogger(int level) {
        this.level = level;
    }

    @Override
    public void write(String message) {
        System.out.println("Error:"+message);
    }
}
```

```java
public class ConsoleLogger extends AbstractLogger {

    public ConsoleLogger(int level) {
        this.level = level;
    }

    @Override
    public void write(String message) {
        System.out.println("Standard Console:"+message);
    }
}
```

```java
public class FileLogger extends AbstractLogger {

    public FileLogger(int level) {
        this.level = level;
    }

    @Override
    public void write(String message) {
        System.out.println("file:"+message);
    }
}
```



接下来创建请求处理链

```java
public class MyTest {

    //设计一条链出来
    private static AbstractLogger getChainOfLogger(){
        AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);     //3
        AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);       //2
        AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);  //1

        errorLogger.setNextLogger(fileLogger);
        fileLogger.setNextLogger(consoleLogger);

        return errorLogger;
    }

    public static void main(String[] args) {
        AbstractLogger chain = getChainOfLogger();
        chain.logMessage(AbstractLogger.INFO,"This is an information");
        chain.logMessage(AbstractLogger.DEBUG, "This is a debug level information.");
        chain.logMessage(AbstractLogger.ERROR, "This is an error information.");

    }

}
```



## 3、总结

**优点：** 

- 降低耦合度。它将请求的发送者和接收者解耦。 
- 简化了对象。使得对象不需要知道链的结构。 
- 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 
- 增加新的请求处理类很方便。

**缺点：** 

- 不能保证请求一定被接收。 
- 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
- 可能不容易观察运行时的特征，有碍于除错。



# 解释器模式

## 1、是什么

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。

说白了，就是定义一句话，然后去设计实现这句话

这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。

解释器模式包含以下主要角色。

- 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
- 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
- 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
- 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
- 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。



## 2、举例

![image-20210408221411995](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210408221411995.png)

```java
//创建一个表达式接口。
public interface Expression {

    public boolean interpret(String context);   //解释方法

}
```



```java
//终结符表达式类
public class TerminalExpression implements Expression {

    private String data;

    public TerminalExpression(String data) {
        this.data = data;
    }

    @Override
    public boolean interpret(String context) {
        //对终结符表达式的处理
        if(context.contains(data)){
            return true;
        }
        return false;
    }
}
```



```java
//非终结符表达式类
public class AndExpression implements Expression {

    private Expression expression = null;
    private Expression expression2 = null;

    public AndExpression(Expression expression, Expression expression2) {
        this.expression = expression;
        this.expression2 = expression2;
    }

    @Override
    public boolean interpret(String context) {
        return expression.interpret(context) && expression2.interpret(context);
    }
}
```



```java
public class OrExpression implements Expression {

    private Expression expression = null;
    private Expression expression2 = null;

    public OrExpression(Expression expression, Expression expression2) {
        this.expression = expression;
        this.expression2 = expression2;
    }

    @Override
    public boolean interpret(String context) {
        return expression.interpret(context) || expression2.interpret(context);
    }
}
```



然后用户来定义上下文

```java
public class MyTest {

    //创建两个Context
    //规则：Robert 和 John 是男性
    public static Expression getMaleExpression(){
        Expression robert = new TerminalExpression("Robert");
        Expression john = new TerminalExpression("John");
        return new OrExpression(robert, john);
    }

    //规则：Julie 是一个已婚的女性
    //<expression> ::= <已婚>的<女性>
    public static Expression getMarriedWomanExpression(){
        Expression julie = new TerminalExpression("Julie");
        Expression married = new TerminalExpression("Married");
        return new AndExpression(julie, married);
    }

    public static void main(String[] args) {
        Expression isMale = getMaleExpression();
        Expression isMarriedWoman = getMarriedWomanExpression();

        System.out.println("John is male? " + isMale.interpret("John"));
        System.out.println("Julie is a married women? "
                + isMarriedWoman.interpret("Married Julie"));
    }
}
```



## 3、总结

**优点：**

- 可扩展性比较好，灵活。 
- 增加了新的解释表达式的方式。 
- 易于实现简单文法。

**缺点：** 

- 可利用场景比较少。 
- 对于复杂的文法比较难维护。 
- 解释器模式会引起类膨胀。 
- 解释器模式采用递归调用方法。





# 迭代器模式

## 1、是什么

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

迭代器模式属于行为型模式。



  这种模式，我们在大量的容器里面可以看到这种应用，简单的提供一种方法，访问一个容器里面的各个元素，又无需暴露对象的内部表示，保证了数据安全。满足“单一职责原则”和“开闭原则”



**关键代码：**定义接口：hasNext, next。



迭代器模式主要包含以下角色。

- 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
- 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
- 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
- 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。



## 2、举例

```java
//迭代器
public interface Iterator {
    public boolean hasNext();
    public Object next();
}
```



```java
//容器
public interface Container {
    public Iterator getIterator();
}
```



这里可以把这个迭代器单独拿出来，我只是为了偷懒

```java
public class NameRepository implements Container{

    public String[] names = {"Robert" , "John" ,"Julie" , "Lora"};

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator {

        int index;

        @Override
        public boolean hasNext() {
            if(index<names.length){
                return true;
            }
            return false;
        }

        @Override
        public Object next() {
            if(this.hasNext()){
                return names[index++];
            }
            return null;
        }
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        NameRepository nameRepository = new NameRepository();


        for(Iterator iterator = nameRepository.getIterator();iterator.hasNext();){
            String name = (String) iterator.next();
            System.out.println("Name:"+name);
        }
    }
}
```



## 3、总结

**优点：** 

- 它支持以不同的方式遍历一个聚合对象。
- 迭代器简化了聚合类。
- 在同一个聚合上可以有多个遍历。 
- 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

**缺点：**

- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。





# 中介者模式

## 1、是什么

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，且可以独立地改变它们之间的交互，使代码易于维护。中介者模式又叫调停模式，它是迪米特法则的典型应用。



在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。

如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。

![image-20210409105654113](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210409105654113.png)

在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。



## 2、举例

![image-20210409144333774](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210409144333774.png)

这里由于想要偷懒，就不对中介者进行面向接口编程了

```java
//创建中介类。
public class ChatRoom {
    public static void showMessage(User user, String message){
        System.out.println(new Date().toString()
                + " [" + user.getName() +"] : " + message);
    }
}
```



```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void sendMessage(String message){
        ChatRoom.showMessage(this,message);
    }
}
```





```java
public class MyTest {
    public static void main(String[] args) {
        User robert = new User("Robert");
        User john = new User("John");

        robert.sendMessage("Hi! John!");
        john.sendMessage("Hello! Robert!");
    }
}
```

一顿操作下来，我们发现，说白了，就是利用一个中介类，然后对具体实例使用中介类的方法，从而达到解耦的目的

听名字有点像静态代理，但实则不然，要注意区分



## 3、总结

**优点：** 

- 降低了类的复杂度，将**一对多**转化成了**一对一**。 
- 各个类之间的解耦。 
- 符合迪米特原则。

**缺点：**中介者会庞大，变得复杂难以维护。



# 备忘录模式

## 1、是什么

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。

备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。



备忘录模式的主要角色如下。

- 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
- 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
- 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。



## 2、举例

备忘录

```java
public class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}
```



然后创建发起者，创建备忘录

```java
public class Originator {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento saveStateToMemento(){
        return new Memento(state);
    }

    public void getStateFromMemento(Memento memento){
        state = memento.getState();
    }
}
```



然后创建管理者，管理这些备忘录

```java
public class CareTaker {
    private List<Memento> list = new ArrayList<>();

    public void add(Memento memento){
        list.add(memento);
    }

    public Memento get(int index){
        return list.get(index);
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();
        originator.setState("State #1");
        originator.setState("State #2");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #3");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #4");

        System.out.println("Current State: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(0));
        System.out.println("First saved State: " + originator.getState());
        originator.getStateFromMemento(careTaker.get(1));
        System.out.println("Second saved State: " + originator.getState());
    }
}
```



这样既完成了备份，同时又保证了数据安全



## 3、总结

优点

- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合**单一职责**原则。


缺点：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。



# 观察者模式

## 1、是什么

指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式

他解决了一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低藕性，保证高度的协作

**关键代码：**在抽象类里有一个 ArrayList 存放观察者们。





## 2、举例

```java
//目标类
//它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
public class Subject {
    private List<Observer> list = new ArrayList<>();

    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
    }

    public void attach(Observer observer){
        list.add(observer);
    }

    public void notifyAllObserver(){
        for (Observer observer : list) {
            observer.update();
        }
    }
}
```

```java
//观察者
public interface Observer {
    public void update();
}
```

```java
public class BinaryObserver implements Observer{
    private Subject subject;

    public BinaryObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Binary String: "
                + Integer.toBinaryString( subject.getState() ) );
    }
}
```

```java
public class HexaObserver implements Observer{
    private Subject subject;

    public HexaObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Hex  String: "
                + Integer.toHexString( subject.getState() ) );
    }
}
```

```java
public class OctalObserver implements Observer{
    private Subject subject;

    public OctalObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println( "Octal String: "
                + Integer.toOctalString( subject.getState() ) );
    }
}
```

```java
public class MyTest {
    public static void main(String[] args) {
        Subject subject = new Subject();

        new BinaryObserver(subject);
        new HexaObserver(subject);
        new OctalObserver(subject);

        System.out.println("First state change: 15");
        subject.setState(15);
        subject.notifyAllObserver();
        System.out.println("Second state change: 10");
        subject.setState(10);
        subject.notifyAllObserver();
    }
}
```



## 3、总结

优点：

- 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合**依赖倒置**原则。
- 目标与观察者之间建立了一套触发机制。

缺点

- 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
- 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。



# 状态模式

## 1、是什么

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。



状态模式包含以下主要角色。

- 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
- 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
- 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。



## 2、举例

```java
public interface State {
    public void doAction(Context context);
}
```



```java
//它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
public class Context {
    private State state;

    public Context(){
        state = null;
    }

    public void setState(State state){
        this.state = state;
    }

    public State getState(){
        return state;
    }
}
```



```java
public class StartState implements State {
    @Override
    public void doAction(Context context) {
        System.out.println("Player is in start state");
        context.setState(this);
    }

    public String toString(){
        return "Start State";
    }

}
```

```java
public class StopState implements State {
    @Override
    public void doAction(Context context) {
        System.out.println("Player is in stop state");
        context.setState(this);
    }

    public String toString(){
        return "Stop State";
    }

}
```



```java
public class MyTest {
    public static void main(String[] args) {
        Context context = new Context();

        StartState startState = new StartState();
        startState.doAction(context);

        System.out.println(context.getState().toString());

        StopState stopState = new StopState();
        stopState.doAction(context);

        System.out.println(context.getState().toString());
    }

}
```



## 3、总结

优点

1. 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“**单一职责原则**”。
2. 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
3. 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。


状态模式的主要缺点如下。

1. 状态模式的使用必然会增加系统的类与对象的个数。
2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
3. 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。



# 策略模式

## 1、是什么

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。

当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。

如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。

该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的**责任**和算法的**实现**分割开来，并委派给不同的对象对这些算法进行管理。

所以我们很容易得出，这个算法里面有三个角色

- 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
- 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
- 环境（Context）类：持有一个策略类的引用，最终给客户端调用。



## 2、举例

透过引用调用对象

```java
public interface Strategy {
    public int doOperation(int num1,int num2);
}
```

```java
public class OperationAdd implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1+num2;
    }
}
```

```java
public class OperationMultiply implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1*num2;
    }
}
```

```java
public class OperationSubtract implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1-num2;
    }
}
```

引用

```java
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public int execute(int num1,int num2){
        return strategy.doOperation(num1,num2);
    }
}
```





```java
public class MyTest {
    public static void main(String[] args) {
        Context context = new Context(new OperationAdd());
        System.out.println("10+5="+context.execute(10,5));

        context = new Context(new OperationMultiply());
        System.out.println("10*5="+context.execute(10,5));

        context = new Context(new OperationSubtract());
        System.out.println("10-5="+context.execute(10,5));
    }
}
```



## 3、总结

优点

- 多重条件语句不易维护，而使用策略模式可以**避免使用多重条件**语句，如 if...else 语句、switch...case 语句。
- 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
- 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
- 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
- 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。


缺点

1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
2. 策略模式造成很多的策略类，增加维护难度。



# 模板模式

## 1、是什么

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

举个简单的例子：去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。



所以不难发现，我们在这里只有两个角色

- 抽象的父类：把子类所有共同的东西在父类实现，定下框架，具体细节交给子类各自进行实现
- 子类：对父类中的抽象方法进行各自的重写



## 2、举例

这里举一个游戏的例子，所有的游戏都是按照初始化，开始，结束的流程走，但是他们三个的每一步都有自己的实现方式，所以放到子类去实现，但是流程是一样的，所以放在了父类去实现；

```java
public abstract class Game {
    abstract void initialize();
    abstract void startPlay();
    abstract void endPlay();

    //模板
    public final void play(){

        //初始化游戏
        initialize();

        //开始游戏
        startPlay();

        //结束游戏
        endPlay();
    }
}
```



```java
public class Football extends Game {
    @Override
    void initialize() {
        System.out.println("Football Game Initialized! Start playing.");
    }

    @Override
    void startPlay() {
        System.out.println("Football Game Started. Enjoy the game!");
    }

    @Override
    void endPlay() {
        System.out.println("Football Game Finished!");
    }
}
```

```java
public class Cricket extends Game {
    @Override
    void initialize() {
        System.out.println("Cricket Game Initialized! Start playing.");
    }

    @Override
    void startPlay() {
        System.out.println("Cricket Game Started. Enjoy the game!");
    }

    @Override
    void endPlay() {
        System.out.println("Cricket Game Finished!");
    }
}
```



```java
public class MyTest {
    public static void main(String[] args) {
        Game game = new Cricket();
        game.play();
        System.out.println("=====================");
        game = new Football();
        game.play();
    }
}
```



## 3、总结

**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。



# 访问者模式

## 1、是什么

在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。

访问者模式包含以下主要角色。

1. 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
2. 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
3. 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
4. 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
5. 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。



## 2、举例

一个更好的理解，就是相当于我们通过不同的方式去看代不同的东西，就可以得到不同的答案

我们通过不同的观察者，去实现元素的方法，自然就会得到不同的结果

![image-20210410120429728](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210410120429728.png)

元素接口

```java
public interface ComputerPart {
    public void accept(ComputerPartVisitor computerPartVisitor);
}
```



```java
public class Mouse implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}
```

```java
public class Monitor implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}
```

```java
public class Keyboard implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}
```



访问者接口

```java
public interface ComputerPartVisitor {
    public void visit(Computer computer);
    public void visit(Mouse mouse);
    public void visit(Keyboard keyboard);
    public void visit(Monitor monitor);
}
```

```java
public class ComputerPartDisplayVisitor implements ComputerPartVisitor {
    @Override
    public void visit(Computer computer) {
        System.out.println("Displaying Computer.");
    }

    @Override
    public void visit(Mouse mouse) {
        System.out.println("Displaying Mouse.");
    }

    @Override
    public void visit(Keyboard keyboard) {
        System.out.println("Displaying Keyboard.");
    }

    @Override
    public void visit(Monitor monitor) {
        System.out.println("Displaying Monitor.");
    }
}
```



对象结构

```java
public class Computer implements ComputerPart {

    ComputerPart[] parts;

    public Computer(){
        parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};
    }


    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        for (int i = 0; i < parts.length; i++) {
            parts[i].accept(computerPartVisitor);
        }
        computerPartVisitor.visit(this);
    }
}
```



通过访问者访问元素

```java
public class MyTest {
    public static void main(String[] args) {

        ComputerPart computer = new Computer();
        computer.accept(new ComputerPartDisplayVisitor());
    }
}
```



## 3、总结

优点

1. 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
2. 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
3. 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
4. 符合**单一职责**原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。


缺点

1. 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
2. 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
	3. 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。